"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var warning_1 = tslib_1.__importDefault(require("warning"));
function clamp(val, max) {
  if (max === void 0) {max = 1;}
  warning_1["default"](0 <= val && val <= max, val + " exceeds [0, " + max + "] interval, clamping");
  return Math.min(max, Math.max(0, val));
}
exports.clamp = clamp;
function integerFromPercent(n, size) {
  return Math.round(parseFloat(n) * size / 100);
}
exports.integerFromPercent = integerFromPercent;
function floatFromPercent(n) {
  return parseFloat((parseFloat(n) / 100).toFixed(5));
}
exports.floatFromPercent = floatFromPercent;
function roundToPrecision(n, precision) {
  if (precision === void 0) {precision = 2;}
  return parseFloat(n.toFixed(precision));
}
exports.roundToPrecision = roundToPrecision;
function extractColorParts(input, solidRegex, alphaRegex) {
  var parts = input.match(solidRegex);
  if (!parts && alphaRegex) {
    parts = input.match(alphaRegex);
  }
  if (!parts) {
    throw new Error(input + " does not match color patterns: [\n      " + solidRegex + "\n      " + alphaRegex + "\n    ]");
  }
  return parts;
}
exports.extractColorParts = extractColorParts;
function parseRGBParts(parts) {
  var r = parseToInteger(parts[1], 255);
  var g = parseToInteger(parts[2], 255);
  var b = parseToInteger(parts[3], 255);
  var a = parts[4] ? parseToFloat(parts[4]) : 1.0;
  if (isNaN(r)) {
    throw new Error("Could not parse red=" + parts[1] + " to number");
  }
  if (isNaN(g)) {
    throw new Error("Could not parse green=" + parts[2] + " to number");
  }
  if (isNaN(b)) {
    throw new Error("Could not parse blue=" + parts[3] + " to number");
  }
  if (isNaN(a)) {
    throw new Error("Could not parse alpha=" + parts[4] + " to number");
  }
  return { r: r, g: g, b: b, a: a };
}
exports.parseRGBParts = parseRGBParts;
function parseHSLParts(parts) {
  var h = parseInt(parts[1], 10);
  var s = parseToFloat(parts[2]);
  var l = parseToFloat(parts[3]);
  var a = parts[4] ? parseToFloat(parts[4]) : 1.0;
  if (isNaN(h)) {
    throw new Error("Could not parse hue=" + parts[1] + " to number");
  } else
  if (isNaN(s)) {
    throw new Error("Could not parse saturation=" + parts[2] + " to number");
  } else
  if (isNaN(l)) {
    throw new Error("Could not parse lightness=" + parts[3] + " to number");
  } else
  if (isNaN(a)) {
    throw new Error("Could not parse alpha=" + parts[4] + " to number");
  }
  return { h: h, s: s, l: l, a: a };
}
exports.parseHSLParts = parseHSLParts;
function parseToInteger(part, size) {
  return part.endsWith('%') ? integerFromPercent(part, size) : parseInt(part, 10);
}
exports.parseToInteger = parseToInteger;
function parseToFloat(part) {
  return part.endsWith('%') ? floatFromPercent(part) : parseFloat(part);
}
exports.parseToFloat = parseToFloat;
function hue2rgb(hue, t1, t2) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue > 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return t2 + (t1 - t2) * 6 * hue;
  }
  if (hue < 1 / 2) {
    return t1;
  }
  if (hue < 2 / 3) {
    return t2 + (t1 - t2) * (2 / 3 - hue) * 6;
  }
  return t2;
}
exports.hue2rgb = hue2rgb;