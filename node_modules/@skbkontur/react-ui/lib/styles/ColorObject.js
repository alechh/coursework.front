"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ColorHelpers_1 = require("./ColorHelpers");
var warning_1 = tslib_1.__importDefault(require("warning"));
var ColorObject = /** @class */function () {
  function ColorObject(rgb, alpha, type) {
    this.rgb = rgb;
    this.alpha = alpha;
    this.type = type;
  }
  ColorObject.prototype.luma = function () {
    var r = this.rgb[0] / 255;
    var g = this.rgb[1] / 255;
    var b = this.rgb[2] / 255;
    r = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    g = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4);
    b = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4);
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  };
  ColorObject.prototype.toHEXString = function () {
    warning_1["default"](this.alpha === 1, "There is an alpha channel=" + this.alpha + ", converting to HEX will discard opacity");
    return '#' +
    this.rgb.
    map(function (c) {
      c = ColorHelpers_1.clamp(Math.round(c), 255);
      return (c < 16 ? '0' : '') + c.toString(16);
    }).
    join('');
  };
  ColorObject.prototype.toRGB = function () {
    return { r: this.rgb[0], g: this.rgb[1], b: this.rgb[2], a: this.alpha };
  };
  ColorObject.prototype.toRGBString = function () {
    return this.alpha < 1 ?
    "rgba(" + this.rgb[0] + ", " + this.rgb[1] + ", " + this.rgb[2] + ", " + this.alpha + ")" :
    "rgb(" + this.rgb[0] + ", " + this.rgb[1] + ", " + this.rgb[2] + ")";
  };
  ColorObject.prototype.toHSL = function () {
    var r = this.rgb[0] / 255;
    var g = this.rgb[1] / 255;
    var b = this.rgb[2] / 255;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var hDeg = 0;
    var s = 0;
    var l = (max + min) / 2;
    if (max !== min) {
      var d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          hDeg = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          hDeg = (b - r) / d + 2;
          break;
        case b:
          hDeg = (r - g) / d + 4;
          break;}

      hDeg = Math.round(hDeg * 60);
    }
    return {
      h: hDeg,
      s: ColorHelpers_1.roundToPrecision(s, 2),
      l: ColorHelpers_1.roundToPrecision(l, 2),
      a: this.alpha };

  };
  ColorObject.prototype.toHSLString = function () {
    var hsl = this.toHSL();
    return hsl.a < 1 ?
    "hsla(" + hsl.h + ", " + hsl.s * 100 + "%, " + hsl.l * 100 + "%, " + hsl.a + ")" :
    "hsl(" + hsl.h + ", " + hsl.s * 100 + "%, " + hsl.l * 100 + "%)";
  };
  ColorObject.prototype.toColorString = function (type) {
    if (type === void 0) {type = this.type;}
    switch (type) {
      case 'rgb':
      case 'rgba':{
          return this.toRGBString();
        }
      case 'hsl':
      case 'hsla':{
          return this.toHSLString();
        }
      case 'transparent':{
          return "transparent";
        }
      default:
        return this.toHEXString();}

  };
  return ColorObject;
}();
exports.ColorObject = ColorObject;