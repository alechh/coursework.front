"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var react_dom_1 = tslib_1.__importDefault(require("react-dom"));
var lodash_debounce_1 = tslib_1.__importDefault(require("lodash.debounce"));
var utils_1 = require("./utils");
var handlers = [];
function addHandleEvent() {
  /**
                            * Firefox do not supports 'focusin' event.
                            * Focus events bubbles multiple time
                            * without possibilty to cancell bubbling.
                            * Using debounce to capture only first focus event
                            * Mozilla Firefix
                            *   ¯\_(ツ)_/¯
                            */
  document.body.addEventListener(utils_1.isFirefox ? 'focus' : 'focusin', utils_1.isFirefox ? lodash_debounce_1["default"](handleNativeFocus, 0, { leading: true, trailing: false }) : handleNativeFocus, utils_1.isFirefox);
}
if (typeof document !== 'undefined') {
  if (document.readyState === 'complete') {
    addHandleEvent();
  } else
  {
    window.addEventListener('load', addHandleEvent);
  }
}
function handleNativeFocus(event) {
  // FIXME: not safe casting
  var target = event.target || event.srcElement;
  handlers.forEach(function (handler) {
    var elements = handler.elements;
    if (typeof elements === 'function') {
      elements = elements();
    }
    if (elements.some(containsTargetOrRenderContainer(target))) {
      return;
    }
    react_dom_1["default"].unstable_batchedUpdates(function () {return handler.callback(event);});
  });
}
function containsTargetOrRenderContainer(target) {
  return function (element) {
    if (!element) {
      return false;
    }
    if (element.contains(target)) {
      return true;
    }
    var container = findRenderContainer(target, element);
    return !!container && element.contains(container);
  };
}
exports.containsTargetOrRenderContainer = containsTargetOrRenderContainer;
/**
                                                                            * Searches RenderContainer placed in "rootNode" for "node"
                                                                            */
function findRenderContainer(node, rootNode, container) {
  var currentNode = node.parentNode;
  if (!currentNode ||
  node === rootNode ||
  currentNode === rootNode ||
  currentNode === document.body ||
  currentNode === document.documentElement ||
  !(currentNode instanceof Element)) {
    return container ? container : null;
  }
  var newContainerId = currentNode.getAttribute('data-rendered-container-id');
  if (newContainerId) {
    var nextNode = document.querySelector("[data-render-container-id~=\"" + newContainerId + "\"]");
    if (!nextNode) {
      throw Error("Origin node for container with id " + newContainerId + " was not found");
    }
    return findRenderContainer(nextNode, rootNode, nextNode);
  }
  return findRenderContainer(currentNode, rootNode, container);
}
function listen(elements, callback) {
  var handler = {
    elements: elements,
    callback: callback };

  handlers.push(handler);
  return {
    remove: function remove() {
      var index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    } };

}
exports["default"] = listen;