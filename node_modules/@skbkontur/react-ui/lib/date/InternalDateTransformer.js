"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var constants_1 = require("./constants");
var InternalDateValidator_1 = tslib_1.__importDefault(require("./InternalDateValidator"));
var types_1 = require("./types");
var InternalDateTransformer = /** @class */function () {
  function InternalDateTransformer() {
  }
  InternalDateTransformer.dateToFragments = function (components, settings) {
    if (settings === void 0) {settings = {};}
    var _a = settings.order,order = _a === void 0 ? constants_1.defaultDateComponentsOrder : _a,_b = settings.separator,separator = _b === void 0 ? constants_1.defaultDateComponentsSeparator : _b,_c = settings.withSeparator,withSeparator = _c === void 0 ? false : _c,_d = settings.withPad,withPad = _d === void 0 ? false : _d,pad = settings.pad;
    var year = {
      type: types_1.InternalDateComponentType.Year,
      value: components.year,
      length: constants_1.LENGTH_YEAR };

    var month = {
      type: types_1.InternalDateComponentType.Month,
      value: components.month,
      length: constants_1.LENGTH_MONTH };

    var date = {
      type: types_1.InternalDateComponentType.Date,
      value: components.date,
      length: constants_1.LENGTH_DATE };

    var fragments = [];
    if (order === types_1.InternalDateOrder.YMD) {
      fragments.push(year, month, date);
    } else
    if (order === types_1.InternalDateOrder.MDY) {
      fragments.push(month, date, year);
    } else
    if (order === types_1.InternalDateOrder.DMY) {
      fragments.push(date, month, year);
    }
    if (withPad) {
      year.valueWithPad = InternalDateTransformer.padYear(year.value, pad);
      month.valueWithPad = InternalDateTransformer.padMonth(month.value, pad);
      date.valueWithPad = InternalDateTransformer.padDate(date.value, pad);
    }
    year.isValid = InternalDateValidator_1["default"].testParseToNumber(year.value);
    month.isValid = InternalDateValidator_1["default"].testParseToNumber(month.value);
    date.isValid = InternalDateValidator_1["default"].testParseToNumber(date.value);
    if (withSeparator) {
      var separatorFragment = {
        type: types_1.InternalDateComponentType.Separator,
        value: separator,
        length: constants_1.LENGTH_SEPARATOR };

      fragments.splice(1, 0, separatorFragment);
      fragments.splice(3, 0, separatorFragment);
    }
    return fragments;
  };
  InternalDateTransformer.parseValueToDate = function (value, order) {
    if (order === void 0) {order = constants_1.defaultDateComponentsOrder;}
    if (!value) {
      return null;
    }
    var re = order === types_1.InternalDateOrder.MDY ? constants_1.RE_ORDER_MDY : order === types_1.InternalDateOrder.DMY ? constants_1.RE_ORDER_DMY : constants_1.RE_ORDER_YMD;
    if (!re.test(value)) {
      return null;
    }
    var match = re.exec(value);
    var dateComponents = tslib_1.__assign({}, constants_1.emptyDateComponents);
    if (match) {
      var matchFinished = match.
      slice(1).
      map(function (item) {return InternalDateValidator_1["default"].testParseToNumber(item) ? Number(item) : null;});
      if (order === types_1.InternalDateOrder.YMD) {
        dateComponents.year = matchFinished[0], dateComponents.month = matchFinished[1], dateComponents.date = matchFinished[2];
      } else
      if (order === types_1.InternalDateOrder.MDY) {
        dateComponents.year = matchFinished[2], dateComponents.month = matchFinished[0], dateComponents.date = matchFinished[1];
      } else
      if (order === types_1.InternalDateOrder.DMY) {
        dateComponents.year = matchFinished[2], dateComponents.month = matchFinished[1], dateComponents.date = matchFinished[0];
      }
    }
    return dateComponents;
  };
  InternalDateTransformer.dateComponentsStringToNumber = function (componentsRaw) {
    if (componentsRaw === null) {
      return { year: 0, month: 0, date: 0 };
    }
    var year = componentsRaw.year,month = componentsRaw.month,date = componentsRaw.date;
    return { year: Number(year), month: Number(month), date: Number(date) };
  };
  InternalDateTransformer.dateToInternalString = function (components) {
    return InternalDateTransformer.dateToFragments(components, {
      withPad: true,
      withSeparator: false,
      order: types_1.InternalDateOrder.DMY }).

    filter(function (_a) {
      var value = _a.value;
      return value !== null;
    }).
    map(function (_a) {
      var valueWithPad = _a.valueWithPad;
      return valueWithPad;
    }).
    join(types_1.InternalDateSeparator.Dot);
  };
  InternalDateTransformer.padStart = function (value, length, pad) {
    if (pad === void 0) {pad = constants_1.CHAR_PAD;}
    return String(value || '').padStart(length, pad);
  };
  InternalDateTransformer.padYear = function (year, pad) {
    return InternalDateTransformer.padStart(year, constants_1.LENGTH_YEAR, pad);
  };
  InternalDateTransformer.padMonth = function (month, pad) {
    return InternalDateTransformer.padStart(month, constants_1.LENGTH_MONTH, pad);
  };
  InternalDateTransformer.padDate = function (date, pad) {
    return InternalDateTransformer.padStart(date, constants_1.LENGTH_DATE, pad);
  };
  InternalDateTransformer.padDateComponent = function (type, value, pad) {
    if (type === types_1.InternalDateComponentType.Year) {
      return InternalDateTransformer.padYear(value, pad);
    } else
    if (type === types_1.InternalDateComponentType.Month) {
      return InternalDateTransformer.padMonth(value, pad);
    } else
    if (type === types_1.InternalDateComponentType.Date) {
      return InternalDateTransformer.padDate(value, pad);
    }
    return '';
  };
  return InternalDateTransformer;
}();
exports["default"] = InternalDateTransformer;