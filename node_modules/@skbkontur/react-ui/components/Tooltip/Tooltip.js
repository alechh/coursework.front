"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var Popup_1 = tslib_1.__importDefault(require("../Popup"));
var RenderLayer_1 = tslib_1.__importDefault(require("../RenderLayer"));
var cross_1 = tslib_1.__importDefault(require("../internal/cross"));
var Tooltip_module_less_1 = tslib_1.__importDefault(require("./Tooltip.module.css"));
var warning_1 = tslib_1.__importDefault(require("warning"));
var lodash_isequal_1 = tslib_1.__importDefault(require("lodash.isequal"));
var listenFocusOutside_1 = require("../../lib/listenFocusOutside");
var Tooltip_styles_1 = tslib_1.__importDefault(require("./Tooltip.styles"));
var Emotion_1 = require("../../lib/theming/Emotion");
var ThemeConsumer_1 = require("../ThemeConsumer");
var POPUP_MARGIN = 15;
var POPUP_PIN_OFFSET = 17;
var Positions = [
'right bottom',
'right middle',
'right top',
'top right',
'top center',
'top left',
'left top',
'left middle',
'left bottom',
'bottom left',
'bottom center',
'bottom right'];

var Tooltip = /** @class */function (_super) {
  tslib_1.__extends(Tooltip, _super);
  function Tooltip() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = { opened: false, focused: false };
    _this.hoverTimeout = null;
    _this.contentElement = null;
    _this.positions = null;
    _this.clickedOutside = true;
    _this.renderContent = function () {
      var content = _this.props.render ? _this.props.render() : null;
      if (content == null) {
        return null;
      }
      return React.createElement("div", { ref: _this.refContent, className: Tooltip_module_less_1["default"].tooltipContent },
      content,
      _this.renderCloseButton());
    };
    _this.refContent = function (node) {
      _this.contentElement = node;
    };
    _this.open = function () {return _this.setState({ opened: true });};
    _this.close = function () {return _this.setState({ opened: false });};
    _this.handleMouseEnter = function (event) {
      var isHoverAnchor = _this.props.trigger === 'hoverAnchor';
      if (isHoverAnchor && event.target === _this.contentElement) {
        return;
      }
      _this.clearHoverTimeout();
      _this.hoverTimeout = window.setTimeout(_this.open, Tooltip.delay);
    };
    _this.handleMouseLeave = function (event) {
      if (_this.props.trigger === 'hover&focus' && _this.state.focused ||
      _this.props.trigger === 'hover' && event.relatedTarget === _this.contentElement) {
        return;
      }
      _this.clearHoverTimeout();
      if (_this.props.trigger === 'hoverAnchor') {
        _this.close();
      } else
      {
        _this.hoverTimeout = window.setTimeout(_this.close, Tooltip.delay);
      }
    };
    _this.handleClick = function () {
      _this.open();
    };
    _this.handleClickOutsideAnchor = function (event) {
      _this.clickedOutside = _this.isClickOutsideContent(event);
      if (_this.clickedOutside) {
        if (_this.props.onCloseRequest) {
          _this.props.onCloseRequest();
        }
        _this.close();
      }
    };
    _this.handleFocus = function () {
      _this.setState({ focused: true });
      _this.open();
    };
    _this.handleBlur = function () {
      if (_this.props.trigger === 'hover&focus' && _this.clickedOutside) {
        _this.close();
      }
      if (_this.props.trigger === 'focus') {
        _this.close();
      }
      _this.clickedOutside = true;
      _this.setState({ focused: false });
    };
    _this.handleCloseButtonClick = function (event) {
      event.stopPropagation();
      if (_this.props.onCloseClick) {
        _this.props.onCloseClick(event);
      }
      if (event.defaultPrevented) {
        return;
      }
      if (_this.props.onCloseRequest) {
        _this.props.onCloseRequest();
      }
      _this.close();
    };
    return _this;
  }
  Tooltip.prototype.componentWillReceiveProps = function (nextProps) {
    if (nextProps.trigger === 'closed') {
      this.close();
    }
    var _a = this.props,allowedPositions = _a.allowedPositions,pos = _a.pos;
    var posChanged = nextProps.pos !== pos;
    var allowedChanged = !lodash_isequal_1["default"](nextProps.allowedPositions, allowedPositions);
    if (posChanged || allowedChanged) {
      this.positions = null;
    }
  };
  Tooltip.prototype.componentWillUnmount = function () {
    this.clearHoverTimeout();
  };
  Tooltip.prototype.render = function () {
    var _this = this;
    return React.createElement(ThemeConsumer_1.ThemeConsumer, null, function (theme) {
      _this.theme = theme;
      return _this.renderMain();
    });
  };
  Tooltip.prototype.renderCloseButton = function () {
    var hasCross = this.props.closeButton === undefined ?
    Tooltip.triggersWithoutCloseButton.indexOf(this.props.trigger) === -1 :
    this.props.closeButton;
    if (!hasCross) {
      return null;
    }
    return React.createElement("span", { className: Emotion_1.cx(Tooltip_module_less_1["default"].cross, Tooltip_styles_1["default"].cross(this.theme)), onClick: this.handleCloseButtonClick }, cross_1["default"]);
  };
  Tooltip.prototype.renderMain = function () {
    var props = this.props;
    var content = this.renderContent();
    var _a = this.getProps(),popupProps = _a.popupProps,_b = _a.layerProps,layerProps = _b === void 0 ? { active: false } : _b;
    var anchorElement = props.children || props.anchorElement;
    var popup = this.renderPopup(anchorElement, popupProps, content);
    return React.createElement(RenderLayer_1["default"], tslib_1.__assign({}, layerProps), popup);
  };
  Tooltip.prototype.renderPopup = function (anchorElement, popupProps, content) {
    return React.createElement(Popup_1["default"], tslib_1.__assign({ anchorElement: anchorElement, hasPin: true, hasShadow: true, margin: POPUP_MARGIN, maxWidth: "none", opened: this.state.opened, pinOffset: POPUP_PIN_OFFSET, disableAnimations: this.props.disableAnimations, positions: this.getPositions(), ignoreHover: this.props.trigger === 'hoverAnchor', onOpen: this.props.onOpen }, popupProps), content);
  };
  Tooltip.prototype.getPositions = function () {
    if (!this.positions) {
      var allowedPositions = this.props.allowedPositions;
      var index = allowedPositions.indexOf(this.props.pos);
      if (index === -1) {
        throw new Error('Unexpected position passed to Tooltip. Expected one of: ' + allowedPositions.join(', '));
      }
      this.positions = allowedPositions.slice(index).concat(allowedPositions.slice(0, index));
    }
    return this.positions;
  };
  Tooltip.prototype.getProps = function () {
    var props = this.props;
    var useWrapper = !!props.children && props.useWrapper;
    switch (props.trigger) {
      case 'opened':
        return {
          layerProps: {
            active: true,
            onClickOutside: this.handleClickOutsideAnchor },

          popupProps: {
            opened: true,
            useWrapper: useWrapper } };


      case 'closed':
        return {
          popupProps: {
            opened: false,
            useWrapper: useWrapper } };


      case 'hoverAnchor':
      case 'hover':
        return {
          popupProps: {
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            useWrapper: useWrapper } };


      case 'click':
        return {
          layerProps: {
            active: this.state.opened,
            onClickOutside: this.handleClickOutsideAnchor },

          popupProps: {
            onClick: this.handleClick,
            useWrapper: useWrapper } };


      case 'focus':
        return {
          popupProps: {
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            useWrapper: useWrapper } };


      case 'hover&focus':
        return {
          layerProps: {
            onClickOutside: this.handleClickOutsideAnchor },

          popupProps: {
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            onMouseEnter: this.handleMouseEnter,
            onMouseLeave: this.handleMouseLeave,
            useWrapper: useWrapper } };


      default:
        throw new Error('Unknown trigger specified: ' + props.trigger);}

  };
  Tooltip.prototype.clearHoverTimeout = function () {
    if (this.hoverTimeout) {
      clearTimeout(this.hoverTimeout);
      this.hoverTimeout = null;
    }
  };
  Tooltip.prototype.isClickOutsideContent = function (event) {
    if (this.contentElement && event.target instanceof Element) {
      return !listenFocusOutside_1.containsTargetOrRenderContainer(event.target)(this.contentElement);
    }
    return true;
  };
  Tooltip.__KONTUR_REACT_UI__ = 'Tooltip';
  Tooltip.propTypes = {
    children: function children(props, propName, componentName) {
      var children = props[propName];
      warning_1["default"](children || props.anchorElement, "[" + componentName + "]: you must provide either 'children' or 'anchorElement' prop for " + componentName + " to work properly");
      warning_1["default"](!(Array.isArray(children) && props.useWrapper === false), "[" + componentName + "]: you provided multiple children, but useWrapper={false} - forcing wrapper <span/> for positioning to work correctly");
    } };

  Tooltip.defaultProps = {
    pos: 'top left',
    trigger: 'hover',
    allowedPositions: Positions,
    disableAnimations: Boolean(process.env.enableReactTesting),
    useWrapper: true,
    closeOnChildrenMouseLeave: false };

  Tooltip.delay = 100;
  Tooltip.triggersWithoutCloseButton = ['hover', 'hoverAnchor', 'focus', 'hover&focus'];
  return Tooltip;
}(React.PureComponent);
exports["default"] = Tooltip;