"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var normalize_wheel_1 = tslib_1.__importDefault(require("normalize-wheel"));
var constants_1 = require("../../lib/date/constants");
var config_1 = tslib_1.__importDefault(require("./config"));
var CalendarUtils = tslib_1.__importStar(require("./CalendarUtils"));
var Animation_1 = require("./Animation");
var CDS = tslib_1.__importStar(require("./CalendarDateShape"));
var MonthViewModel_1 = require("./MonthViewModel");
var CalendarScrollEvents_1 = tslib_1.__importDefault(require("./CalendarScrollEvents"));
var Month_1 = require("./Month");
var Calendar_module_less_1 = tslib_1.__importDefault(require("./Calendar.module.css"));
var Calendar_styles_1 = tslib_1.__importDefault(require("./Calendar.styles"));
var Emotion_1 = require("../../lib/theming/Emotion");
var ThemeConsumer_1 = tslib_1.__importDefault(require("../ThemeConsumer"));
var getTodayDate = function getTodayDate() {
  var date = new Date();
  return {
    date: date.getDate(),
    month: date.getMonth(),
    year: date.getFullYear() };

};
var wrapperStyle = { height: config_1["default"].WRAPPER_HEIGHT };
var Calendar = /** @class */function (_super) {
  tslib_1.__extends(Calendar, _super);
  function Calendar(props) {
    var _this = _super.call(this, props) || this;
    _this.animation = Animation_1.Animation();
    /**
                                                * Scrolls calendar to given date
                                                * @public
                                                */
    _this.scrollToMonth = function (month, year) {return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var _a, minDate, maxDate, currentMonth, diffInMonths, maxMonthsToAdd, onEnd, isYearChanges, monthsToPrependCount, monthsToPrepend_1, monthsToAppendCount_1, monthsToAppend_1;
        var _this = this;
        return tslib_1.__generator(this, function (_b) {
          switch (_b.label) {
            case 0:
              if (!this.animation.inProgress()) return [3 /*break*/, 2];
              this.animation.finish();
              // FIXME: Dirty hack to await batched updates
              return [4 /*yield*/, new Promise(function (r) {return setTimeout(r);})];
            case 1:
              // FIXME: Dirty hack to await batched updates
              _b.sent();
              _b.label = 2;
            case 2:
              _a = this.props, minDate = _a.minDate, maxDate = _a.maxDate;
              if (minDate && CDS.isGreater(minDate, CDS.create(32, month, year))) {
                this.scrollToMonth(minDate.month, minDate.year);
                return [2 /*return*/];
              }
              if (maxDate && CDS.isLess(maxDate, CDS.create(0, month, year))) {
                this.scrollToMonth(maxDate.month, maxDate.year);
                return [2 /*return*/];
              }
              currentMonth = this.state.months[1];
              diffInMonths = currentMonth.month + currentMonth.year * 12 - month - year * 12;
              if (diffInMonths === 0) {
                this.scrollTo(0);
                return [2 /*return*/];
              }
              maxMonthsToAdd = config_1["default"].MAX_MONTHS_TO_APPEND_ON_SCROLL;
              onEnd = function onEnd() {
                return _this.setState({
                  months: CalendarUtils.getMonths(month, year),
                  scrollPosition: 0 });

              };
              isYearChanges = function isYearChanges(state) {
                return state.months[1].year !== year &&
                // if diff in months is 2 or less,
                // either year is not changing either months already
                // have right isFirstInYear/isLastInYear flags
                Math.abs(diffInMonths) > 2;
              };
              // If scrolling upwards, prepend maximum maxMonthsToAdd months
              // and scroll to the first month
              if (diffInMonths > 0) {
                monthsToPrependCount = Math.min(Math.abs(diffInMonths) - 1, maxMonthsToAdd);
                monthsToPrepend_1 = Array.from({ length: monthsToPrependCount }, function (_, index) {
                  return MonthViewModel_1.MonthViewModel.create(month + index, year);
                });
                this.setState(function (state) {
                  var yearChanges = isYearChanges(state);
                  if (yearChanges) {
                    // Mutating here can lead to some unexpected bugs
                    // but we couldn't find any yet
                    state.months[0].isFirstInYear = true;
                    if (monthsToPrepend_1.length) {
                      // Mutating item here is safe as it was just created
                      monthsToPrepend_1[monthsToPrepend_1.length - 1].isLastInYear = true;
                    }
                  }
                  return {
                    months: monthsToPrepend_1.concat(state.months),
                    scrollPosition: -CalendarUtils.getMonthsHeight(monthsToPrepend_1) };

                }, function () {
                  var targetPosition = _this.state.months[0].height;
                  _this.scrollTo(targetPosition, onEnd);
                });
              }
              // If scrolling downwards, append maximum maxMonthsToAdd months
              // and scroll to the last but one month
              if (diffInMonths < 0) {
                monthsToAppendCount_1 = Math.min(Math.abs(diffInMonths), maxMonthsToAdd);
                monthsToAppend_1 = Array.from({ length: monthsToAppendCount_1 }, function (_, index) {
                  return MonthViewModel_1.MonthViewModel.create(month + index - monthsToAppendCount_1 + 2, year);
                });
                this.setState(function (state) {
                  if (isYearChanges(state)) {
                    // Mutating here can lead to some unexpected bugs
                    // but we couldn't find any yet
                    state.months[state.months.length - 1].isLastInYear = true;
                    // Mutating item here is safe as it was just created
                    if (monthsToAppend_1[0]) {
                      monthsToAppend_1[0].isFirstInYear = true;
                    }
                  }
                  return { months: state.months.concat(monthsToAppend_1) };
                }, function () {
                  var targetPosition = -1 * CalendarUtils.getMonthsHeight(_this.state.months.slice(1, -2));
                  _this.scrollTo(targetPosition, onEnd);
                });
              }
              return [2 /*return*/];}

        });
      });};
    _this.refRoot = function (element) {
      if (!_this.root && element) {
        element.addEventListener('wheel', _this.handleWheel, { passive: false });
      }
      if (_this.root && !element) {
        _this.root.removeEventListener('wheel', _this.handleWheel);
      }
      _this.root = element;
    };
    _this.handleMonthYearChange = function (month, year) {
      _this.scrollToMonth(month, year);
    };
    _this.handleWheel = function (event) {
      if (!(event instanceof WheelEvent)) {
        return;
      }
      event.preventDefault();
      var pixelY = normalize_wheel_1["default"](event).pixelY;
      _this.setState(function (_a) {
        var months = _a.months,scrollPosition = _a.scrollPosition,scrollTarget = _a.scrollTarget;
        var targetPosition = CalendarUtils.calculateScrollPosition(months, scrollPosition, pixelY).scrollPosition;
        return { scrollTarget: targetPosition };
      }, _this.handleWheelEnd);
      _this.animation.animate(pixelY, function (deltaY) {
        // FIXME: Typescript not resolving setState cb type
        return _this.setState(CalendarUtils.applyDelta(deltaY));
      });
      CalendarScrollEvents_1["default"].emit();
    };
    _this.handleWheelEnd = function () {
      if (_this.wheelEndTimeout) {
        clearTimeout(_this.wheelEndTimeout);
      }
      _this.wheelEndTimeout = window.setTimeout(_this.scrollToNearestWeek, 300);
    };
    _this.scrollToNearestWeek = function () {
      var _a = _this.state,scrollTarget = _a.scrollTarget,scrollDirection = _a.scrollDirection;
      var trasholdHeight = config_1["default"].MONTH_TITLE_OFFSET_HEIGHT + config_1["default"].DAY_HEIGHT;
      if (scrollTarget < trasholdHeight) {
        var targetPosition_1 = 0;
        if (scrollDirection < 0) {
          targetPosition_1 = trasholdHeight;
        }
        _this.setState({ scrollTarget: targetPosition_1 }, function () {
          var amount = scrollTarget - targetPosition_1;
          _this.animation.animate(amount, function (deltaY) {
            // FIXME: Typescript not resolving setState cb type
            return _this.setState(CalendarUtils.applyDelta(deltaY));
          });
        });
      }
    };
    _this.scrollTo = function (pos, onEnd) {
      var scrollAmmount = pos - _this.state.scrollPosition;
      return _this.scrollAmount(scrollAmmount, onEnd);
    };
    _this.scrollAmount = function (scrollAmmount, onEnd) {
      return _this.animation.animate(scrollAmmount, function (deltaY) {
        return _this.setState(function (_a) {
          var scrollPosition = _a.scrollPosition;
          return {
            scrollPosition: scrollPosition + deltaY };

        });
      }, onEnd);
    };
    var today = getTodayDate();
    var initialMonth = props.initialMonth == null ? today.month : props.initialMonth;
    var initialYear = props.initialYear == null ? today.year : props.initialYear;
    _this.state = {
      scrollPosition: 0,
      months: CalendarUtils.getMonths(initialMonth, initialYear),
      today: today,
      scrollDirection: 1,
      scrollTarget: 0 };

    return _this;
  }
  Calendar.prototype.componentWillUnmount = function () {
    if (this.animation.inProgress()) {
      this.animation.cancel();
    }
  };
  Calendar.prototype.render = function () {
    var _this = this;
    return React.createElement(ThemeConsumer_1["default"], null, function (theme) {
      _this.theme = theme;
      return _this.renderMain();
    });
  };
  Calendar.prototype.renderMain = function () {
    var positions = this.getMonthPositions();
    return React.createElement("div", { ref: this.refRoot, className: Emotion_1.cx(Calendar_module_less_1["default"].root, Calendar_styles_1["default"].root(this.theme)) },
    React.createElement("div", { style: wrapperStyle, className: Calendar_module_less_1["default"].wrapper }, this.state.months.
    map(function (x, i) {return [positions[i], x];}).
    filter(function (_a) {
      var top = _a[0],month = _a[1];
      return CalendarUtils.isMonthVisible(top, month);
    }).
    map(this.renderMonth, this)));
  };
  Calendar.prototype.renderMonth = function (_a) {
    var top = _a[0],month = _a[1];
    return React.createElement(Month_1.Month, { key: month.month + '-' + month.year, top: top, month: month, maxDate: this.props.maxDate, minDate: this.props.minDate, today: this.state.today, value: this.props.value, onDateClick: this.props.onSelect, onMonthYearChange: this.handleMonthYearChange, isHoliday: this.props.isHoliday });
  };
  Calendar.prototype.getMonthPositions = function () {
    var _a = this.state,scrollPosition = _a.scrollPosition,months = _a.months;
    var positions = [scrollPosition - months[0].height];
    for (var i = 1; i < months.length; i++) {
      var position = positions[i - 1] + months[i - 1].height;
      positions.push(position);
    }
    return positions;
  };
  Calendar.__KONTUR_REACT_UI__ = 'Calendar';
  Calendar.defaultProps = {
    holidays: [],
    minDate: {
      year: constants_1.MIN_YEAR,
      month: constants_1.MIN_MONTH,
      date: constants_1.MIN_DATE },

    maxDate: {
      year: constants_1.MAX_YEAR,
      month: constants_1.MAX_MONTH,
      date: constants_1.MAX_DATE } };


  return Calendar;
}(React.Component);
exports["default"] = Calendar;