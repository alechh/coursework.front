"use strict";
var _this = void 0;
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var types_1 = require("../types");
var AddressElement_1 = require("./AddressElement");
var FiasData_1 = require("./FiasData");
var lodash_isequal_1 = tslib_1.__importDefault(require("lodash.isequal"));
var Address = /** @class */function () {
  function Address(_a) {
    var _b = _a === void 0 ? {} : _a,fields = _b.fields,additionalFields = _b.additionalFields,errors = _b.errors,country = _b.country,foreignAddress = _b.foreignAddress;
    var _this = this;
    this.getAddressErrors = function () {
      return tslib_1.__assign({}, _this.errors);
    };
    this.getText = function (minField, skipTypes, connector) {
      if (skipTypes === void 0) {skipTypes = false;}
      if (connector === void 0) {connector = ', ';}
      if (_this.isEmpty) {
        return '';
      }
      var getElementText = function getElementText(element) {
        return element ? element.getText(skipTypes) : '';
      };
      var fields = minField ? Address.getParentFields(minField) : Address.MAIN_FIELDS;
      return fields.
      map(function (field) {return getElementText(_this.fields[field]);}).
      filter(Boolean).
      join(connector);
    };
    this.getFullText = function (withPostalCode) {
      if (withPostalCode === void 0) {withPostalCode = false;}
      var substrings = [];
      if (withPostalCode) {
        substrings.push(_this.postalCode);
      }
      if (_this.country) {
        substrings.push(_this.country.fullName);
      }
      substrings.push(_this.isForeign ? _this.foreignAddress : _this.getText());
      return substrings.filter(Boolean).join(', ');
    };
    this.isAllowedToFill = function (field) {
      var _a = _this.fields,region = _a.region,city = _a.city,settlement = _a.settlement,house = _a.house;
      var hasCityOrSettlement = city || settlement || region && region.isFederalCity;
      if (!hasCityOrSettlement && (field === types_1.Fields.street || field === types_1.Fields.stead || field === types_1.Fields.house) ||
      !house && field === types_1.Fields.room) {
        return false;
      }
      return true;
    };
    this.isAllowedToSearchFullAddress = function (field) {
      return Address.FULL_ADDRESS_SEARCH_FIELDS.includes(field);
    };
    // doesn't fully work on api side yet
    // @see https://yt.skbkontur.ru/issue/PS-1401
    this.isAllowedToSearchThroughChildrenOfDirectParent = function (field, fieldsSettings) {
      if (fieldsSettings) {
        for (var _i = 0, _a = Address.getParentFields(field); _i < _a.length; _i++) {
          var parentField = _a[_i];
          if (!Address.isFieldVisible(parentField, fieldsSettings)) {
            return false;
          }
        }
      }
      return Address.NOT_ONLY_DIRECT_PARENT_SEARCH_FIELDS.includes(field);
    };
    this.hasOnlyIndirectParent = function (field) {
      if (field) {
        var parents = Address.getParentFields(field);
        if (parents.length > 1) {
          var directParent = _this.fields[parents.pop()];
          return !directParent && parents.some(function (parent) {return Boolean(_this.fields[parent]);});
        }
      }
      return false;
    };
    this.getClosestParentFiasId = function (field) {
      if (!_this.isEmpty) {
        var parents = Address.getParentFields(field).
        slice().
        reverse();
        for (var _i = 0, parents_1 = parents; _i < parents_1.length; _i++) {
          var parentField = parents_1[_i];
          var parent_1 = _this.fields[parentField];
          if (parent_1) {
            return parent_1.fiasId;
          }
        }
      }
    };
    this.getFiasId = function () {
      if (!_this.isEmpty) {
        var fields = Address.MAIN_FIELDS.slice().reverse();
        for (var _i = 0, fields_1 = fields; _i < fields_1.length; _i++) {
          var field = fields_1[_i];
          var element = _this.fields[field];
          if (element && element.fiasId) {
            return element.fiasId;
          }
        }
      }
      return '';
    };
    this.getParent = function (field) {
      if (_this.fields[field]) {
        var parents = Address.getParentFields(field).filter(function (f) {return Boolean(_this.fields[f]);});
        var closest = parents.pop();
        if (closest) {
          return _this.fields[closest];
        }
      }
    };
    this.verifyConsistency = function () {
      var verifiedFields = tslib_1.__assign({}, _this.fields);
      for (var _i = 0, _a = Address.MAIN_FIELDS; _i < _a.length; _i++) {
        var field = _a[_i];
        var element = _this.fields[field];
        if (element) {
          if (element.data) {
            var expectedParentFiasId = element.data.parentFiasId;
            var parent_2 = _this.getParent(field);
            if (!parent_2 || parent_2.fiasId === expectedParentFiasId) {
              verifiedFields[field] = element;
              continue;
            }
          }
          return {
            address: Address.fieldsToResponse(verifiedFields),
            isValid: false,
            invalidLevel: field };

        }
      }
      return {
        address: Address.fieldsToResponse(verifiedFields),
        isValid: true };

    };
    this.getFiasPostalCode = function () {
      if (!_this.isEmpty) {
        var fields = Address.MAIN_FIELDS.slice().reverse();
        for (var _i = 0, fields_2 = fields; _i < fields_2.length; _i++) {
          var field = fields_2[_i];
          var element = _this.fields[field];
          if (element && element.data && element.data.postalCode) {
            return element.data.postalCode;
          }
        }
      }
      return '';
    };
    this.getAddressValue = function () {
      var fields = Object.keys(_this.fields);
      return fields.reduce(function (value, field) {
        var _a;
        var element = _this.fields[field];
        if (!element) {
          return value;
        }
        var name = element.name,fiasData = element.fiasData;
        return tslib_1.__assign({}, value, (_a = {}, _a[field] = tslib_1.__assign({ name: name }, fiasData ? { data: fiasData } : {}), _a));
      }, {});
    };
    // TODO: get fields usage from fieldsSettings
    this.getValue = function (withPostalCode) {
      if (withPostalCode === void 0) {withPostalCode = false;}
      var _a = _this,country = _a.country,foreignAddress = _a.foreignAddress;
      return tslib_1.__assign({ address: _this.getAddressValue(), addressString: _this.getFullText(withPostalCode), addressErrors: _this.getAddressErrors(), fiasId: _this.getFiasId(), postalCode: _this.postalCode }, country ? { country: country } : {}, _this.isForeign ? { foreignAddress: foreignAddress } : {});
    };
    this.convertForVerification = function () {
      return Address.VERIFIABLE_FIELDS.reduce(function (value, field) {
        var _a;
        var element = _this.fields[field];
        if (!element) {
          return value;
        }
        return tslib_1.__assign({}, value, (_a = {}, _a[field] = tslib_1.__assign({}, element.verifiableData), _a));
      }, {});
    };
    this.getDiffFields = function (address, fieldsSettings) {
      var fields = fieldsSettings ? Address.filterVisibleFields(address.fields, fieldsSettings) : tslib_1.__assign({}, address.fields);
      for (var _i = 0, _a = Address.MAIN_FIELDS; _i < _a.length; _i++) {
        var field = _a[_i];
        var element = fields[field];
        if (element) {
          if (element.isEqualTo(_this.fields[field])) {
            delete fields[field];
          } else
          {
            break;
          }
        }
      }
      return fields;
    };
    this.fields = fields || {};
    this.additionalFields = additionalFields || {};
    this.errors = errors || {};
    this.country = country;
    this.foreignAddress = foreignAddress || '';
  }
  Object.defineProperty(Address.prototype, "isForeign", {
    get: function get() {
      return Boolean(this.country && !Address.IS_RUSSIA(this.country));
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(Address.prototype, "isEmpty", {
    get: function get() {
      var _this = this;
      return !Address.MAIN_FIELDS.some(function (field) {return _this.fields.hasOwnProperty(field);});
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(Address.prototype, "hasErrors", {
    get: function get() {
      return Object.keys(this.errors).length > 0;
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(Address.prototype, "postalCode", {
    get: function get() {
      var value = this.additionalFields[types_1.ExtraFields.postalcode];
      return typeof value === 'string' ? value : this.getFiasPostalCode();
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(Address.prototype, "isPostalCodeValid", {
    get: function get() {
      var rusFormat = /^[\d]{6}$/;
      var foreignFormat = /^[\w\.\-\s]*$/;
      return (!this.country || this.isForeign ? foreignFormat : rusFormat).test(this.postalCode);
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(Address.prototype, "isPostalCodeAltered", {
    get: function get() {
      var fiasPostalCode = this.getFiasPostalCode();
      return Boolean(fiasPostalCode) && this.postalCode !== fiasPostalCode;
    },
    enumerable: true,
    configurable: true });

  Address.prototype.hasError = function (field) {
    return this.errors.hasOwnProperty(field);
  };
  Address.prototype.getError = function (field) {
    return this.errors[field];
  };
  Address.MAIN_FIELDS = [
  types_1.Fields.region,
  types_1.Fields.district,
  types_1.Fields.city,
  types_1.Fields.intracityarea,
  types_1.Fields.settlement,
  types_1.Fields.planningstructure,
  types_1.Fields.street,
  types_1.Fields.stead,
  types_1.Fields.house,
  types_1.Fields.room];

  Address.ADDITIONAL_FIELDS = [types_1.ExtraFields.postalcode];
  Address.ALL_FIELDS = Address.MAIN_FIELDS.concat(Address.ADDITIONAL_FIELDS);
  Address.VERIFIABLE_FIELDS = [
  types_1.Fields.region,
  types_1.Fields.district,
  types_1.Fields.city,
  types_1.Fields.intracityarea,
  types_1.Fields.settlement,
  types_1.Fields.planningstructure,
  types_1.Fields.street];

  Address.FULL_ADDRESS_SEARCH_FIELDS = [
  types_1.Fields.district,
  types_1.Fields.city,
  types_1.Fields.intracityarea,
  types_1.Fields.settlement,
  types_1.Fields.planningstructure,
  types_1.Fields.street];

  Address.NOT_ONLY_DIRECT_PARENT_SEARCH_FIELDS = [
  types_1.Fields.district,
  types_1.Fields.city,
  types_1.Fields.intracityarea,
  types_1.Fields.settlement,
  types_1.Fields.planningstructure,
  types_1.Fields.street];

  Address.IS_RUSSIA = function (country) {
    return lodash_isequal_1["default"](country, {
      shortName: 'Россия',
      fullName: 'Российская Федерация',
      code: '643' });

  };
  Address.responseToFields = function (response) {
    var fields = {};
    if (response) {
      Address.MAIN_FIELDS.forEach(function (field) {
        var fiasObject = response[field];
        if (fiasObject) {
          var data = new FiasData_1.FiasData(fiasObject);
          fields[field] = new AddressElement_1.AddressElement(field, data.name, data);
        }
      });
    }
    return fields;
  };
  Address.fieldsToResponse = function (fields) {
    var response = {};
    if (fields) {
      Address.MAIN_FIELDS.forEach(function (field) {
        var element = fields[field];
        if (element && element.fiasData) {
          response[field] = element.fiasData;
        }
      });
    }
    return response;
  };
  Address.createFromResponse = function (response, additionalFields, country) {
    return new Address({ fields: Address.responseToFields(response), additionalFields: additionalFields, country: country });
  };
  Address.createFromAddressValue = function (addressValue, additionalFields, country) {
    var fields = {};
    if (addressValue) {
      Address.MAIN_FIELDS.forEach(function (field) {
        var addressField = addressValue[field];
        if (addressField) {
          var name_1 = addressField.name,data = addressField.data;
          fields[field] = new AddressElement_1.AddressElement(field, name_1, data && new FiasData_1.FiasData(data));
        }
      });
    }
    return new Address({ fields: fields, additionalFields: additionalFields, country: country });
  };
  Address.createFromAddress = function (address, options) {
    var fields = address.fields,additionalFields = address.additionalFields,errors = address.errors,country = address.country,foreignAddress = address.foreignAddress;
    return new Address(tslib_1.__assign({ fields: fields,
      additionalFields: additionalFields,
      errors: errors,
      country: country,
      foreignAddress: foreignAddress }, options));
  };
  Address.validate = function (address, locale) {
    var fields = address.fields;
    var errors = {};
    for (var _i = 0, _a = Address.MAIN_FIELDS; _i < _a.length; _i++) {
      var field = _a[_i];
      var element = fields[field];
      var error = '';
      if (element) {
        if (!element.data) {
          error = locale.addressNotVerified;
        }
        if (!address.isAllowedToFill(field)) {
          error = locale[field + "FillBefore"];
        }
        if (Boolean(error)) {
          errors[field] = error;
          break;
        }
      }
    }
    if (Object.keys(errors).length === 0) {
      if (address.postalCode && !address.isPostalCodeValid) {
        errors[types_1.ExtraFields.postalcode] = locale.postalcodeNotValid;
      } else
      if (address.isPostalCodeAltered) {
        errors[types_1.ExtraFields.postalcode] = locale.postalcodeNotFound;
      }
    }
    return Address.createFromAddress(address, { errors: errors });
  };
  Address.verify = function (address, response) {
    if (address.isEmpty) {
      return address;
    }
    var addressResponse = response.address,invalidLevel = response.invalidLevel;
    var verifiedAddress = Address.createFromAddress(address, {
      fields: tslib_1.__assign({}, address.fields, Address.responseToFields(addressResponse)) });

    var invalidField = invalidLevel || verifiedAddress.verifyConsistency().invalidLevel;
    if (invalidField) {
      return Address.removeFiasData(verifiedAddress, [invalidField].concat(Address.getChildFields(invalidField)));
    }
    return verifiedAddress;
  };
  // TODO: Hide invisible fields without removing them.
  // (removing can break the verification)
  Address.filterVisibleFields = function (fields, fieldsSettings) {
    var filteredFields = {};
    var field;
    for (field in fields) {
      if (Address.isFieldVisible(field, fieldsSettings)) {
        filteredFields[field] = fields[field];
      }
    }
    return filteredFields;
  };
  Address.isFieldVisible = function (field, fieldsSettings) {
    var settings = fieldsSettings[field];
    return Boolean(settings && settings.visible);
  };
  Address.getParentFields = function (field) {
    var index = Address.MAIN_FIELDS.indexOf(field);
    return index > -1 ? Address.MAIN_FIELDS.slice(0, index) : [];
  };
  Address.getChildFields = function (field) {
    var index = Address.MAIN_FIELDS.indexOf(field);
    return index > -1 ? Address.MAIN_FIELDS.slice(index + 1) : [];
  };
  Address.removeFiasData = function (address, fields) {
    if (fields === void 0) {fields = Address.MAIN_FIELDS;}
    var addressFields = tslib_1.__assign({}, address.fields);
    for (var _i = 0, fields_3 = fields; _i < fields_3.length; _i++) {
      var field = fields_3[_i];
      var element = addressFields[field];
      if (element) {
        element.removeData();
      }
    }
    return Address.createFromAddress(address, { fields: addressFields });
  };
  Address.getAddress = function (api, value, fieldsSettings) {return tslib_1.__awaiter(_this, void 0, void 0, function () {
      var _a, address, addressString, fiasId, postalCode, country, foreignAddress, additionalFields, searchOptions, addressValue, _b, success, data, addressResponse;
      return tslib_1.__generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            if (!value) {
              return [2 /*return*/, new Address()];
            }
            address = value.address, addressString = value.addressString, fiasId = value.fiasId, postalCode = value.postalCode, country = value.country, foreignAddress = value.foreignAddress;
            additionalFields = {};
            searchOptions = {};
            if (postalCode) {
              additionalFields[types_1.ExtraFields.postalcode] = postalCode;
            }
            if (country && !Address.IS_RUSSIA(country)) {
              return [2 /*return*/, new Address({
                country: country,
                foreignAddress: foreignAddress,
                additionalFields: (_a = {}, _a[types_1.ExtraFields.postalcode] = postalCode, _a) })];

            }
            if (address) {
              addressValue = fieldsSettings ? Address.filterVisibleFields(address, fieldsSettings) : address;
              return [2 /*return*/, Address.createFromAddressValue(addressValue, additionalFields, country)];
            }
            if (fiasId) {
              searchOptions = {
                fiasId: fiasId };

            }
            if (addressString) {
              searchOptions = {
                searchText: addressString,
                limit: 1 };

            }
            if (!api) return [3 /*break*/, 2];
            return [4 /*yield*/, api.search(searchOptions)];
          case 1:
            _b = _c.sent(), success = _b.success, data = _b.data;
            if (success && data && data.length) {
              addressResponse = fieldsSettings ? Address.filterVisibleFields(data[0], fieldsSettings) : data[0];
              return [2 /*return*/, Address.createFromResponse(addressResponse, additionalFields, country)];
            }
            _c.label = 2;
          case 2:return [2 /*return*/, new Address({ country: country })];}

      });
    });};
  return Address;
}();
exports.Address = Address;
exports["default"] = Address;