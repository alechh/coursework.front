"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var PropTypes = tslib_1.__importStar(require("prop-types"));
var LayoutEvents_1 = tslib_1.__importDefault(require("../../lib/LayoutEvents"));
var Sticky_module_less_1 = tslib_1.__importDefault(require("./Sticky.module.css"));
var utils_1 = require("../../lib/utils");
var Emotion_1 = require("../../lib/theming/Emotion");
var warning_1 = tslib_1.__importDefault(require("warning"));
var shallowEqual_1 = tslib_1.__importDefault(require("fbjs/lib/shallowEqual"));
var ZIndex_1 = tslib_1.__importDefault(require("../ZIndex"));
var MAX_REFLOW_RETRIES = 5;
var Sticky = /** @class */function (_super) {
  tslib_1.__extends(Sticky, _super);
  function Sticky() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      fixed: false,
      deltaHeight: 0,
      stopped: false,
      relativeTop: 0 };

    _this.layoutSubscription = { remove: null };
    _this.reflowCounter = 0;
    _this.refWrapper = function (ref) {return _this.wrapper = ref;};
    _this.refInner = function (ref) {return _this.inner = ref;};
    _this.reflow = function () {
      var documentElement = document.documentElement;
      if (!documentElement) {
        throw Error('There is no "documentElement" in document');
      }
      var windowHeight = window.innerHeight || documentElement.clientHeight;
      if (!_this.wrapper || !_this.inner) {
        return;
      }
      var _a = _this.wrapper.getBoundingClientRect(),top = _a.top,bottom = _a.bottom,left = _a.left;
      var _b = _this.inner.getBoundingClientRect(),width = _b.width,height = _b.height;
      var _c = _this.props,offset = _c.offset,getStop = _c.getStop,side = _c.side;
      var _d = _this.state,prevFixed = _d.fixed,_e = _d.height,prevHeight = _e === void 0 ? height : _e;
      var fixed = side === 'top' ? top < offset : bottom > windowHeight - offset;
      _this.setState({ fixed: fixed, left: left });
      if (fixed && !prevFixed) {
        _this.setState({ width: width, height: height });
      }
      if (fixed) {
        var stop_1 = getStop && getStop();
        if (stop_1) {
          var deltaHeight = prevHeight - height;
          var stopRect = stop_1.getBoundingClientRect();
          var outerHeight_1 = height + offset;
          var stopped = false;
          var relativeTop = 0;
          if (side === 'top') {
            stopped = stopRect.top - outerHeight_1 < 0;
            relativeTop = stopRect.top - height - top;
          } else
          {
            stopped = stopRect.bottom + outerHeight_1 > windowHeight;
            relativeTop = stopRect.bottom - top;
          }
          _this.setState({ relativeTop: relativeTop, deltaHeight: deltaHeight, stopped: stopped });
        }
      }
    };
    return _this;
  }
  Sticky.prototype.componentDidMount = function () {
    warning_1["default"](this.props.allowChildWithMargins === undefined, '"allowChildWithMargins" prop is deprecated. Component "Sticky" work correctly without it.');
    this.reflow();
    this.layoutSubscription = LayoutEvents_1["default"].addListener(this.reflow);
  };
  Sticky.prototype.componentWillUnmount = function () {
    if (this.layoutSubscription.remove) {
      this.layoutSubscription.remove();
    }
  };
  Sticky.prototype.componentDidUpdate = function (prevProps, prevState) {
    if (!shallowEqual_1["default"](prevProps, this.props) || !shallowEqual_1["default"](prevState, this.state)) {
      if (this.reflowCounter < MAX_REFLOW_RETRIES) {
        LayoutEvents_1["default"].emit();
        this.reflowCounter += 1;
        return;
      }
    }
    this.reflowCounter = 0;
  };
  Sticky.prototype.render = function () {
    var _a;
    var children = this.props.children;
    var _b = this.props,side = _b.side,offset = _b.offset;
    var _c = this.state,fixed = _c.fixed,stopped = _c.stopped,relativeTop = _c.relativeTop,deltaHeight = _c.deltaHeight,width = _c.width,height = _c.height,left = _c.left;
    var innerStyle = {};
    if (fixed) {
      if (stopped) {
        innerStyle.top = relativeTop;
        innerStyle[side === 'top' ? 'marginTop' : 'marginBottom'] = deltaHeight;
      } else
      {
        innerStyle.width = width;
        innerStyle[side] = offset;
        innerStyle.left = left;
      }
    }
    if (utils_1.isFunction(children)) {
      children = children(fixed);
    }
    return React.createElement("div", { ref: this.refWrapper },
    React.createElement(ZIndex_1["default"], { priority: "Sticky", applyZIndex: fixed, className: Emotion_1.cx(Sticky_module_less_1["default"].inner, (_a = {},
      _a[Sticky_module_less_1["default"].fixed] = fixed,
      _a[Sticky_module_less_1["default"].stopped] = stopped,
      _a)), style: innerStyle, wrapperRef: this.refInner },
    React.createElement("div", { className: Emotion_1.cx(Sticky_module_less_1["default"].container) }, children)),
    fixed && !stopped ? React.createElement("div", { style: { width: width, height: height } }) : null);
  };
  Sticky.__KONTUR_REACT_UI__ = 'Sticky';
  Sticky.propTypes = {
    children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
                                                                      * Функция, которая возвращает DOM-элемент, который нельзя пересекать.
                                                                      */
    getStop: PropTypes.func,
    /**
                              * Отступ от границы в пикселях
                              */
    offset: PropTypes.number,
    side: PropTypes.oneOf(['top', 'bottom']).isRequired,
    allowChildWithMargins: PropTypes.bool };

  Sticky.defaultProps = { offset: 0 };
  return Sticky;
}(React.Component);
exports["default"] = Sticky;