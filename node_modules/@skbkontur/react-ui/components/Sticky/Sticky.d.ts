import * as React from 'react';
import * as PropTypes from 'prop-types';
import { Nullable } from '../../typings/utility-types';
export interface StickyProps {
    side: 'top' | 'bottom';
    /**
     * Отступ в пикселях от края экрана, на сколько сдвигается элемент в залипшем состоянии
     * @default 0
     */
    offset: number;
    getStop?: () => Nullable<HTMLElement>;
    children?: React.ReactNode | ((fixed: boolean) => React.ReactNode);
    /**
     * @deprecated работа с margin у детей возможна без указания этого флага
     * @default false
     */
    allowChildWithMargins?: boolean;
}
export interface StickyState {
    fixed: boolean;
    deltaHeight: number;
    height?: number;
    width?: number;
    left?: number;
    stopped: boolean;
    relativeTop: number;
}
export default class Sticky extends React.Component<StickyProps, StickyState> {
    static __KONTUR_REACT_UI__: string;
    static propTypes: {
        children: PropTypes.Requireable<string | number | boolean | {} | PropTypes.ReactElementLike | PropTypes.ReactNodeArray>;
        /**
         * Функция, которая возвращает DOM-элемент, который нельзя пересекать.
         */
        getStop: PropTypes.Requireable<(...args: any[]) => any>;
        /**
         * Отступ от границы в пикселях
         */
        offset: PropTypes.Requireable<number>;
        side: PropTypes.Validator<string>;
        allowChildWithMargins: PropTypes.Requireable<boolean>;
    };
    static defaultProps: {
        offset: number;
    };
    state: StickyState;
    private wrapper;
    private inner;
    private layoutSubscription;
    private reflowCounter;
    componentDidMount(): void;
    componentWillUnmount(): void;
    componentDidUpdate(prevProps: StickyProps, prevState: StickyState): void;
    render(): JSX.Element;
    private refWrapper;
    private refInner;
    private reflow;
}
