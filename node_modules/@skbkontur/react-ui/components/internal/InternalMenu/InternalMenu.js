"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var react_dom_1 = tslib_1.__importDefault(require("react-dom"));
var identifiers_1 = require("../../../lib/events/keyboard/identifiers");
var isActiveElement_1 = tslib_1.__importDefault(require("./isActiveElement"));
var ScrollContainer_1 = tslib_1.__importDefault(require("../../ScrollContainer/ScrollContainer"));
var MenuItem_1 = require("../../MenuItem");
var MenuHeader_1 = require("../../MenuHeader");
var InternalMenu_module_less_1 = tslib_1.__importDefault(require("./InternalMenu.module.css"));
var createPropsGetter_1 = require("../createPropsGetter");
var Emotion_1 = require("../../../lib/theming/Emotion");
var InternalMenu_styles_1 = tslib_1.__importDefault(require("./InternalMenu.styles"));
var ThemeConsumer_1 = require("../../ThemeConsumer");
var InternalMenu = /** @class */function (_super) {
  tslib_1.__extends(InternalMenu, _super);
  function InternalMenu() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      highlightedIndex: -1,
      maxHeight: _this.props.maxHeight || 'none',
      scrollState: 'top' };

    _this.getProps = createPropsGetter_1.createPropsGetter(InternalMenu.defaultProps);
    _this.renderHeader = function () {
      var _a;
      return React.createElement("div", { ref: function ref(el) {return _this.header = el;}, className: Emotion_1.cx((_a = {},
        _a[InternalMenu_module_less_1["default"].header] = true,
        _a[InternalMenu_module_less_1["default"].fixedHeader] = _this.state.scrollState !== 'top',
        _a)) }, _this.props.header);
    };
    _this.renderFooter = function () {
      var _a;
      return React.createElement("div", { ref: function ref(el) {return _this.footer = el;}, className: Emotion_1.cx((_a = {},
        _a[InternalMenu_module_less_1["default"].footer] = true,
        _a[InternalMenu_module_less_1["default"].fixedFooter] = _this.state.scrollState !== 'bottom',
        _a)) }, _this.props.footer);
    };
    _this.focusOnRootElement = function () {
      if (_this.rootElement) {
        _this.rootElement.focus();
      }
    };
    _this.shouldRecalculateMaxHeight = function (prevProps) {
      var _a = _this.props,maxHeight = _a.maxHeight,header = _a.header,footer = _a.footer,children = _a.children;
      var prevMaxHeight = prevProps.maxHeight;
      var prevHeader = prevProps.header;
      var prevFooter = prevProps.footer;
      var prevChildrenCount = React.Children.count(prevProps.children);
      return maxHeight !== prevMaxHeight ||
      footer !== prevFooter ||
      header !== prevHeader ||
      React.Children.count(children) !== prevChildrenCount;
    };
    _this.calculateMaxHeight = function () {
      var maxHeight = _this.props.maxHeight;
      var parsedMaxHeight = maxHeight;
      var calculatedMaxHeight;
      if (typeof maxHeight === 'string' && typeof window !== 'undefined' && _this.rootElement) {
        var rootElementMaxHeight = window.getComputedStyle(_this.rootElement).maxHeight;
        if (rootElementMaxHeight) {
          parsedMaxHeight = parseFloat(rootElementMaxHeight);
        }
      }
      calculatedMaxHeight =
      typeof parsedMaxHeight === 'number' ?
      parsedMaxHeight + (
      _this.header && _this.header.getBoundingClientRect().height || 0) + (
      _this.footer && _this.footer.getBoundingClientRect().height || 0) :
      maxHeight;
      _this.setState({
        maxHeight: calculatedMaxHeight || 'none' });

    };
    _this.setInitialSelection = function () {
      for (var i = _this.getProps().initialSelectedItemIndex; i > -1; i--) {
        _this.moveDown();
      }
    };
    _this.refScrollContainer = function (scrollContainer) {
      _this.scrollContainer = scrollContainer;
    };
    _this.scrollToSelected = function () {
      if (_this.scrollContainer && _this.highlighted) {
        _this.scrollContainer.scrollTo(react_dom_1["default"].findDOMNode(_this.highlighted));
      }
    };
    _this.highlightItem = function (index) {
      _this.setState({ highlightedIndex: index });
      if (_this.rootElement) {
        _this.rootElement.focus();
      }
    };
    _this.unhighlight = function () {
      _this.setState({ highlightedIndex: -1 });
    };
    _this.moveUp = function () {
      _this.move(-1);
    };
    _this.moveDown = function () {
      _this.move(1);
    };
    _this.handleKeyDown = function (e) {
      if (typeof _this.props.onKeyDown === 'function') {
        _this.props.onKeyDown(e);
      }
      if (e.defaultPrevented) {
        return;
      }
      if (identifiers_1.isKeyArrowUp(e)) {
        e.preventDefault();
        _this.moveUp();
      } else
      if (identifiers_1.isKeyArrowDown(e)) {
        e.preventDefault();
        _this.moveDown();
      } else
      if (identifiers_1.isKeyEnter(e)) {
        if (_this.highlighted && _this.highlighted.props.onClick) {
          _this.highlighted.props.onClick(e);
        }
      }
    };
    _this.handleScrollStateChange = function (scrollState) {
      if (_this.state.scrollState !== scrollState) {
        _this.setState({ scrollState: scrollState });
      }
    };
    return _this;
  }
  InternalMenu.prototype.componentDidMount = function () {
    this.setInitialSelection();
    this.calculateMaxHeight();
  };
  InternalMenu.prototype.componentDidUpdate = function (prevProps, prevState) {
    if (this.shouldRecalculateMaxHeight(prevProps)) {
      this.calculateMaxHeight();
    }
  };
  InternalMenu.prototype.componentWillReceiveProps = function (nextProps) {
    if (nextProps.maxHeight !== this.props.maxHeight) {
      this.setState({
        maxHeight: nextProps.maxHeight || 'none' });

    }
  };
  InternalMenu.prototype.focus = function () {
    this.focusOnRootElement();
  };
  InternalMenu.prototype.render = function () {
    var _this = this;
    return React.createElement(ThemeConsumer_1.ThemeConsumer, null, function (theme) {
      _this.theme = theme;
      return _this.renderMain();
    });
  };
  InternalMenu.prototype.renderMain = function () {
    var _this = this;
    var enableIconPadding = React.Children.toArray(this.props.children).some(function (x) {return typeof x === 'object' && x.props.icon;});
    if (this.isEmpty()) {
      return null;
    }
    return React.createElement("div", { className: Emotion_1.cx(InternalMenu_module_less_1["default"].root, InternalMenu_styles_1["default"].root(this.theme), this.props.hasShadow && InternalMenu_module_less_1["default"].shadow), style: {
        width: this.props.width,
        maxHeight: this.state.maxHeight },
      onKeyDown: this.handleKeyDown, ref: function ref(element) {
        _this.rootElement = element;
      }, tabIndex: 0 },
    this.props.header ? this.renderHeader() : null,
    React.createElement(ScrollContainer_1["default"], { ref: this.refScrollContainer, maxHeight: this.props.maxHeight, preventWindowScroll: this.props.preventWindowScroll, onScrollStateChange: this.handleScrollStateChange }, React.Children.map(this.props.children, function (child, index) {
      if (typeof child === 'string' || typeof child === 'number' || child == null) {
        return child;
      }
      if (typeof child.type === 'string') {
        return child;
      }
      if (enableIconPadding && (MenuItem_1.isMenuItem(child) || MenuHeader_1.isMenuHeader(child))) {
        child = React.cloneElement(child, {
          _enableIconPadding: true });

      }
      if (isActiveElement_1["default"](child)) {
        var highlight = _this.state.highlightedIndex === index;
        var ref = child.ref;
        var originalRef_1 = ref;
        if (highlight) {
          ref = function ref(menuItem) {return _this.refHighlighted(originalRef_1, menuItem);};
        }
        return React.cloneElement(child, {
          ref: ref,
          state: highlight ? 'hover' : child.props.state,
          onClick: _this.select.bind(_this, index, false),
          onMouseEnter: function onMouseEnter(event) {
            _this.highlightItem(index);
            if (MenuItem_1.isMenuItem(child) && child.props.onMouseEnter) {
              child.props.onMouseEnter(event);
            }
          },
          onMouseLeave: function onMouseLeave(event) {
            _this.unhighlight();
            if (MenuItem_1.isMenuItem(child) && child.props.onMouseLeave) {
              child.props.onMouseLeave(event);
            }
          } });

      }
      return child;
    })),
    this.props.footer ? this.renderFooter() : null);
  };
  InternalMenu.prototype.refHighlighted = function (originalRef, menuItem) {
    this.highlighted = menuItem;
    if (!originalRef || typeof originalRef === 'string') {
      return;
    }
    if (typeof originalRef === 'function') {
      originalRef(menuItem);
    } else
    if (typeof originalRef === 'object') {
      // @ts-ignore see issue https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065
      originalRef.current = menuItem;
    }
  };
  InternalMenu.prototype.select = function (index, shouldHandleHref, event) {
    var item = childrenToArray(this.props.children)[index];
    if (isActiveElement_1["default"](item)) {
      if (shouldHandleHref && item.props.href) {
        if (item.props.target) {
          window.open(item.props.href, item.props.target);
        } else
        {
          location.href = item.props.href;
        }
      }
      if (item.props.onClick) {
        item.props.onClick(event);
      }
      if (this.props.onItemClick) {
        this.props.onItemClick(event);
      }
      return true;
    }
    return false;
  };
  InternalMenu.prototype.move = function (step) {
    this.setState(function (state, props) {
      var children = childrenToArray(props.children);
      if (!children.some(isActiveElement_1["default"])) {
        return null;
      }
      var index = state.highlightedIndex;
      do {
        index += step;
        if (!props.cyclicSelection && (index < 0 || index > children.length)) {
          return null;
        }
        if (index < 0) {
          index = children.length - 1;
        } else
        if (index > children.length) {
          index = 0;
        }
        var child = children[index];
        if (isActiveElement_1["default"](child)) {
          return { highlightedIndex: index };
        }
      } while (index !== state.highlightedIndex);
      return null;
    }, this.scrollToSelected);
  };
  InternalMenu.prototype.isEmpty = function () {
    var children = this.props.children;
    return !children || !childrenToArray(children).filter(isExist).length;
  };
  InternalMenu.__KONTUR_REACT_UI__ = 'InternalMenu';
  InternalMenu.defaultProps = {
    width: 'auto',
    maxHeight: 300,
    hasShadow: true,
    preventWindowScroll: true,
    cyclicSelection: true,
    initialSelectedItemIndex: -1 };

  return InternalMenu;
}(React.Component);
exports["default"] = InternalMenu;
function isExist(value) {
  return value !== null && value !== undefined;
}
function childrenToArray(children) {
  var ret = [];
  // Use forEach instead of map to avoid cloning for key unifying.
  React.Children.forEach(children, function (child) {
    ret.push(child);
  });
  return ret;
}