"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var ReactDOM = tslib_1.__importStar(require("react-dom"));
var react_focus_lock_1 = tslib_1.__importDefault(require("react-focus-lock"));
var identifiers_1 = require("../../lib/events/keyboard/identifiers");
var LayoutEvents_1 = tslib_1.__importDefault(require("../../lib/LayoutEvents"));
var RenderContainer_1 = tslib_1.__importDefault(require("../RenderContainer/RenderContainer"));
var ZIndex_1 = tslib_1.__importDefault(require("../ZIndex/ZIndex"));
var stopPropagation_1 = tslib_1.__importDefault(require("../../lib/events/stopPropagation"));
var HideBodyVerticalScroll_1 = tslib_1.__importDefault(require("../HideBodyVerticalScroll/HideBodyVerticalScroll"));
var ModalStack_1 = tslib_1.__importDefault(require("../ModalStack"));
var ModalContext_1 = require("./ModalContext");
var ModalFooter_1 = require("./ModalFooter");
var ModalHeader_1 = require("./ModalHeader");
var ModalBody_1 = require("./ModalBody");
var ModalClose_1 = tslib_1.__importDefault(require("./ModalClose"));
var ResizeDetector_1 = tslib_1.__importDefault(require("../internal/ResizeDetector"));
var ensureOldIEClassName_1 = require("../ensureOldIEClassName");
var Modal_module_less_1 = tslib_1.__importDefault(require("./Modal.module.css"));
var Emotion_1 = require("../../lib/theming/Emotion");
var Modal_styles_1 = tslib_1.__importDefault(require("./Modal.styles"));
var ThemeConsumer_1 = require("../ThemeConsumer");
var helpers_1 = require("./helpers");
var mountedModalsCount = 0;
/**
                             * Модальное окно
                             *
                             * Содержит в себе три компоненты: **Modal.Header**,
                             * **Modal.Body** и **Modal.Footer**
                             *
                             * Для отображения серой плашки в футере в компонент
                             * **Footer** необходимо передать пропс **panel**
                             *
                             * Для отключения прилипания шапки и футера
                             * в соответствующий компонет нужно передать
                             * проп **sticky** со значением **false**
                             * (по-умолчанию прилипание включено)
                             */
var Modal = /** @class */function (_super) {
  tslib_1.__extends(Modal, _super);
  function Modal() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      stackPosition: 0,
      horizontalScroll: false };

    _this.stackSubscription = null;
    _this.containerNode = null;
    _this.mouseDownTarget = null;
    _this.mouseUpTarget = null;
    _this.requestClose = function () {
      if (_this.props.disableClose) {
        return;
      }
      if (_this.props.onClose) {
        _this.props.onClose();
      }
    };
    _this.refContainer = function (center) {
      _this.containerNode = center;
    };
    _this.handleStackChange = function (stack) {
      _this.setState({ stackPosition: stack.indexOf(_this) });
    };
    _this.handleContainerMouseDown = function (event) {
      _this.mouseDownTarget = event.target;
    };
    _this.handleContainerMouseUp = function (event) {
      _this.mouseUpTarget = event.target;
    };
    _this.handleContainerClick = function (event) {
      if (!_this.props.ignoreBackgroundClick) {
        var target = event.target,currentTarget = event.currentTarget;
        if (target === currentTarget && _this.mouseDownTarget === currentTarget && _this.mouseUpTarget === currentTarget) {
          _this.requestClose();
        }
      }
    };
    _this.handleKeyDown = function (e) {
      if (_this.state.stackPosition !== 0) {
        return;
      }
      if (identifiers_1.isKeyEscape(e)) {
        stopPropagation_1["default"](e);
        _this.requestClose();
      }
    };
    _this.checkHorizontalScrollAppearance = function () {
      var hasScroll = false;
      if (_this.containerNode) {
        var containerClientWidth = _this.containerNode.clientWidth;
        var containerScrollWidth = _this.containerNode.scrollWidth;
        hasScroll = containerClientWidth < containerScrollWidth;
      }
      if (hasScroll && !_this.state.horizontalScroll) {
        _this.setState({ horizontalScroll: true });
      } else
      if (_this.state.horizontalScroll) {
        _this.setState({ horizontalScroll: false });
      }
    };
    // TODO: без порталов ломается сохранение фокуса внутри модалки
    // NOTE: в ie нормально не работает
    _this.isDisableFocusLock = function () {
      return !ReactDOM.createPortal || ensureOldIEClassName_1.isIE;
    };
    _this.handleResize = function (event) {
      LayoutEvents_1["default"].emit();
    };
    return _this;
  }
  Modal.prototype.componentDidMount = function () {
    this.stackSubscription = ModalStack_1["default"].add(this, this.handleStackChange);
    if (mountedModalsCount === 0) {
      window.addEventListener('resize', this.checkHorizontalScrollAppearance);
    }
    mountedModalsCount++;
    window.addEventListener('keydown', this.handleKeyDown);
    this.checkHorizontalScrollAppearance();
    if (this.containerNode) {
      this.containerNode.addEventListener('scroll', LayoutEvents_1["default"].emit);
    }
  };
  Modal.prototype.componentWillUnmount = function () {
    if (--mountedModalsCount === 0) {
      window.removeEventListener('resize', this.checkHorizontalScrollAppearance);
      LayoutEvents_1["default"].emit();
    }
    window.removeEventListener('keydown', this.handleKeyDown);
    if (this.stackSubscription != null) {
      this.stackSubscription.remove();
    }
    ModalStack_1["default"].remove(this);
    if (this.containerNode) {
      this.containerNode.removeEventListener('scroll', LayoutEvents_1["default"].emit);
    }
  };
  Modal.prototype.render = function () {
    var _this = this;
    return React.createElement(ThemeConsumer_1.ThemeConsumer, null, function (theme) {
      _this.theme = theme;
      return _this.renderMain();
    });
  };
  Modal.prototype.renderMain = function () {
    var _a;
    var hasHeader = false;
    var hasFooter = false;
    var hasPanel = false;
    React.Children.toArray(this.props.children).forEach(function (child) {
      if (ModalHeader_1.isHeader(child)) {
        hasHeader = true;
      }
      if (ModalFooter_1.isFooter(child)) {
        hasFooter = true;
        if (child.props.panel) {
          hasPanel = true;
        }
      }
    });
    var modalContextProps = {
      hasHeader: hasHeader,
      horizontalScroll: this.state.horizontalScroll };

    if (hasHeader && !this.props.noClose) {
      modalContextProps.close = {
        disableClose: this.props.disableClose,
        requestClose: this.requestClose };

    }
    if (!hasFooter) {
      modalContextProps.additionalPadding = true;
    }
    if (hasFooter && hasPanel) {
      modalContextProps.additionalPadding = true;
    }
    var style = {};
    var containerStyle = {};
    if (this.props.width) {
      style.width = this.props.width;
    } else
    {
      containerStyle.width = 'auto';
    }
    return React.createElement(RenderContainer_1["default"], null,
    React.createElement(ZIndex_1["default"], { priority: 'Modal', className: Modal_module_less_1["default"].root },
    React.createElement(HideBodyVerticalScroll_1["default"], null),
    this.state.stackPosition === 0 && React.createElement("div", { className: Emotion_1.cx(Modal_module_less_1["default"].bg, Modal_styles_1["default"].bg(this.theme)) }),
    React.createElement("div", { ref: this.refContainer, className: Modal_module_less_1["default"].container, onMouseDown: this.handleContainerMouseDown, onMouseUp: this.handleContainerMouseUp, onClick: this.handleContainerClick, "data-tid": "modal-container" },
    React.createElement("div", { className: Emotion_1.cx(Modal_module_less_1["default"].centerContainer, Modal_styles_1["default"].centerContainer(this.theme), (_a = {},
      _a[Modal_module_less_1["default"].alignTop] = !!this.props.alignTop,
      _a)), style: containerStyle },
    React.createElement("div", { className: Emotion_1.cx(Modal_module_less_1["default"].window, Modal_styles_1["default"].window(this.theme)), style: style },
    React.createElement(ResizeDetector_1["default"], { onResize: this.handleResize },
    React.createElement(react_focus_lock_1["default"], { disabled: this.isDisableFocusLock(), autoFocus: false },
    !hasHeader && !this.props.noClose ? React.createElement(ZIndex_1["default"], { priority: 'ModalCross', className: Modal_styles_1["default"].closeWrapper() },
    React.createElement(ModalClose_1["default"], { requestClose: this.requestClose, disableClose: this.props.disableClose })) : null,
    React.createElement(ModalContext_1.ModalContext.Provider, { value: modalContextProps },
    React.createElement("div", null, this.props.children)))))))));
  };
  Modal.__KONTUR_REACT_UI__ = 'Modal';
  Modal.Header = ModalHeader_1.Header;
  Modal.Body = ModalBody_1.Body;
  Modal.Footer = ModalFooter_1.Footer;
  Modal.propTypes = {
    children: function children(props, propName, componentName) {
      if (React.Children.toArray(props[propName]).some(function (child) {return !ModalHeader_1.isHeader(child) && !helpers_1.isBody(child) && !ModalFooter_1.isFooter(child);})) {
        return new Error("Only 'Header/Body/Footer' components are allowed for '" + propName + "' prop of '" + componentName + "' component");
      }
    } };

  return Modal;
}(React.Component);
exports["default"] = Modal;