"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var PropTypes = tslib_1.__importStar(require("prop-types"));
var MenuKebab_1 = tslib_1.__importDefault(require("@skbkontur/react-icons/MenuKebab"));
var identifiers_1 = require("../../lib/events/keyboard/identifiers");
var _20px_1 = tslib_1.__importDefault(require("../Icon/20px"));
var LayoutEvents_1 = tslib_1.__importDefault(require("../../lib/LayoutEvents"));
var tabListener_1 = tslib_1.__importDefault(require("../../lib/events/tabListener"));
var PopupMenu_1 = tslib_1.__importDefault(require("../internal/PopupMenu"));
var Kebab_module_less_1 = tslib_1.__importDefault(require("./Kebab.module.css"));
var Emotion_1 = require("../../lib/theming/Emotion");
var Kebab_styles_1 = tslib_1.__importDefault(require("./Kebab.styles"));
var ThemeConsumer_1 = require("../ThemeConsumer");
var Kebab = /** @class */function (_super) {
  tslib_1.__extends(Kebab, _super);
  function Kebab() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      opened: false,
      focusedByTab: false,
      anchor: null };

    _this.listener = {
      remove: function remove() {return undefined;} };

    _this.renderCaption = function (captionProps) {
      var disabled = _this.props.disabled;
      var handleCaptionKeyDown = function handleCaptionKeyDown(event) {
        if (!disabled) {
          _this.handleCaptionKeyDown(event, captionProps.openMenu);
        }
      };
      var handleCaptionClick = function handleCaptionClick() {
        if (!disabled) {
          captionProps.toggleMenu();
        }
      };
      return React.createElement("span", { tabIndex: disabled ? -1 : 0, onClick: handleCaptionClick, onKeyDown: handleCaptionKeyDown, onFocus: _this.handleFocus, onBlur: _this.handleBlur, className: Emotion_1.cx(Kebab_module_less_1["default"].kebab, captionProps.opened && Kebab_module_less_1["default"].opened, disabled && Kebab_module_less_1["default"].disabled, _this.state.focusedByTab && Kebab_module_less_1["default"].focused, _this.state.focusedByTab && Kebab_styles_1["default"].focused(_this.theme)) }, _this.renderIcon());
    };
    _this.handleCaptionKeyDown = function (e, openMenu) {
      if (identifiers_1.someKeys(identifiers_1.isKeyEnter, identifiers_1.isKeySpace, identifiers_1.isKeyArrowVertical)(e)) {
        e.preventDefault();
        openMenu(true);
      }
    };
    _this.handleChangeMenuState = function (isOpened, restoreFocus) {
      _this.setState({
        opened: isOpened,
        focusedByTab: !isOpened && restoreFocus },
      function () {
        if (_this.props.disabled) {
          return;
        }
        if (_this.state.opened) {
          _this.props.onOpen();
        } else
        {
          _this.props.onClose();
        }
      });
    };
    _this.handleFocus = function () {
      if (!_this.props.disabled) {
        // focus event fires before keyDown eventlistener
        // so we should check tabPressed in async way
        process.nextTick(function () {
          if (tabListener_1["default"].isTabPressed) {
            _this.setState({ focusedByTab: true });
          }
        });
      }
    };
    _this.handleBlur = function () {
      _this.setState({
        focusedByTab: false });

    };
    return _this;
  }
  Kebab.prototype.componentDidMount = function () {
    /** addListener'у нужен колбэк в аргумент */
    this.listener = LayoutEvents_1["default"].addListener(function () {return undefined;});
  };
  Kebab.prototype.componentWillUnmount = function () {
    this.listener.remove();
  };
  Kebab.prototype.render = function () {
    var _this = this;
    return React.createElement(ThemeConsumer_1.ThemeConsumer, null, function (theme) {
      _this.theme = theme;
      return _this.renderMain();
    });
  };
  Kebab.prototype.renderMain = function () {
    var _a = this.props,disabled = _a.disabled,positions = _a.positions;
    return React.createElement(PopupMenu_1["default"], { popupMargin: 5, popupPinOffset: 15, popupHasPin: true, positions: positions, onChangeMenuState: this.handleChangeMenuState, caption: this.renderCaption, disableAnimations: this.props.disableAnimations }, !disabled && this.props.children);
  };
  Kebab.prototype.renderIcon = function () {
    switch (this.props.size) {
      case 'small':
        return React.createElement("div", { className: Kebab_module_less_1["default"].iconsmall },
        React.createElement(MenuKebab_1["default"], { size: "14px", color: "#757575" }));
      case 'medium':
        return React.createElement("div", { className: Kebab_module_less_1["default"].iconmedium },
        React.createElement(MenuKebab_1["default"], { size: "18px", color: "#757575" }));
      case 'large':
        return React.createElement("div", { className: Kebab_module_less_1["default"].iconlarge },
        React.createElement(_20px_1["default"], { name: "kebab", color: "#757575" }));
      default:
        throw new Error("Unexpected size '" + this.props.size + "'");}

  };
  Kebab.__KONTUR_REACT_UI__ = 'Kebab';
  Kebab.propTypes = {};
  Kebab.defaultProps = {
    onOpen: function onOpen() {return undefined;},
    onClose: function onClose() {return undefined;},
    positions: ['bottom left', 'bottom right', 'top left', 'top right'],
    size: 'small',
    disableAnimations: Boolean(process.env.enableReactTesting) };

  return Kebab;
}(React.Component);
exports["default"] = Kebab;
Kebab.propTypes = {
  children: PropTypes.node,
  disabled: PropTypes.bool,
  menuMaxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /**
                                                                             * Размер кебаба small 14px | large 20px
                                                                             */
  size: PropTypes.string,
  /**
                           * Коллбек, вызывающийся перед закрытием кебаба
                           */
  onClose: PropTypes.func,
  /**
                            * Коллбек, вызывающийся перед открытием кебаба
                            */
  onOpen: PropTypes.func };