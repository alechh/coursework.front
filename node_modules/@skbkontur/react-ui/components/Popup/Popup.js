"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var react_dom_1 = require("react-dom");
var PropTypes = tslib_1.__importStar(require("prop-types"));
var safePropTypes = tslib_1.__importStar(require("../../lib/SSRSafePropTypes"));
var RenderContainer_1 = tslib_1.__importDefault(require("../RenderContainer"));
var ZIndex_1 = tslib_1.__importDefault(require("../ZIndex"));
var react_transition_group_1 = require("react-transition-group");
var raf_1 = tslib_1.__importDefault(require("raf"));
var PopupHelper_1 = tslib_1.__importDefault(require("./PopupHelper"));
var PopupPin_1 = tslib_1.__importDefault(require("./PopupPin"));
var LayoutEvents_1 = tslib_1.__importDefault(require("../../lib/LayoutEvents"));
var Popup_module_less_1 = tslib_1.__importDefault(require("./Popup.module.css"));
var ensureOldIEClassName_1 = require("../ensureOldIEClassName");
var warning_1 = tslib_1.__importDefault(require("warning"));
var utils_1 = require("../../lib/utils");
var LifeCycleProxy_1 = tslib_1.__importDefault(require("../internal/LifeCycleProxy"));
var Emotion_1 = require("../../lib/theming/Emotion");
var Popup_styles_1 = tslib_1.__importDefault(require("./Popup.styles"));
var ThemeConsumer_1 = require("../ThemeConsumer");
var POPUP_BORDER_DEFAULT_COLOR = 'transparent';
var TRANSITION_TIMEOUT = { enter: 0, exit: 200 };
var DUMMY_LOCATION = {
  position: 'top left',
  coordinates: {
    top: -9999,
    left: -9999 } };


exports.PopupPositions = [
'top left',
'top center',
'top right',
'right top',
'right middle',
'right bottom',
'bottom right',
'bottom center',
'bottom left',
'left bottom',
'left middle',
'left top'];

var Popup = /** @class */function (_super) {
  tslib_1.__extends(Popup, _super);
  function Popup() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = { location: _this.props.opened ? DUMMY_LOCATION : null };
    _this.locationUpdateId = null;
    _this.anchorElement = null;
    _this.refAnchorElement = function (instance) {
      _this.anchorInstance = instance;
      var element = _this.extractElement(instance);
      _this.updateAnchorElement(element);
      _this.anchorElement = element;
    };
    _this.handleMouseEnter = function (event) {
      if (_this.props.onMouseEnter) {
        _this.props.onMouseEnter(event);
      }
    };
    _this.handleMouseLeave = function (event) {
      if (_this.props.onMouseLeave) {
        _this.props.onMouseLeave(event);
      }
    };
    _this.handleClick = function (event) {
      if (_this.props.onClick) {
        _this.props.onClick(event);
      }
    };
    _this.handleFocus = function (event) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };
    _this.handleBlur = function (event) {
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
    };
    _this.resetLocation = function () {
      _this.cancelDelayedUpdateLocation();
      _this.setState({ location: null });
    };
    _this.refPopupElement = function (zIndex) {
      if (zIndex) {
        _this.lastPopupElement = zIndex && react_dom_1.findDOMNode(zIndex);
      }
    };
    _this.handleLayoutEvent = function () {
      if (!_this.state.location) {
        return;
      }
      if (_this.anchorInstance) {
        _this.updateAnchorElement(_this.extractElement(_this.anchorInstance));
      }
      _this.updateLocation();
    };
    _this.handleDidUpdate = function (prevProps, props) {
      var hadNoLocation = prevProps.location === DUMMY_LOCATION;
      var hasLocation = props.location !== DUMMY_LOCATION;
      if (hadNoLocation && hasLocation && _this.props.onOpen) {
        _this.props.onOpen();
      }
    };
    _this.updateLocation = function () {
      var popupElement = _this.lastPopupElement;
      if (!popupElement) {
        return;
      }
      var location = _this.getLocation(popupElement, _this.state.location);
      if (!_this.locationEquals(_this.state.location, location)) {
        _this.setState({ location: location });
      }
    };
    return _this;
  }
  Popup.prototype.componentDidMount = function () {
    this.updateLocation();
    this.layoutEventsToken = LayoutEvents_1["default"].addListener(this.handleLayoutEvent);
  };
  Popup.prototype.componentWillReceiveProps = function (nextProps) {
    /**
                                                                     * For react < 16 version ReactDOM.unstable_renderSubtreeIntoContainer is
                                                                     * used. It causes refs callbacks to call after componentDidUpdate.
                                                                     *
                                                                     * Delaying updateLocation to ensure that ref is set
                                                                     */
    if (nextProps.opened) {
      if (!this.state.location) {
        this.setState({ location: DUMMY_LOCATION });
      }
      this.delayUpdateLocation();
    }
  };
  Popup.prototype.componentWillUnmount = function () {
    this.cancelDelayedUpdateLocation();
    this.removeEventListeners(this.anchorElement);
    if (this.layoutEventsToken) {
      this.layoutEventsToken.remove();
      this.layoutEventsToken = null;
    }
  };
  Popup.prototype.render = function () {
    var _this = this;
    return React.createElement(ThemeConsumer_1.ThemeConsumer, null, function (theme) {
      _this.theme = theme;
      return _this.renderMain();
    });
  };
  Popup.prototype.renderMain = function () {
    var location = this.state.location;
    var _a = this.props,anchorElement = _a.anchorElement,useWrapper = _a.useWrapper;
    var child = null;
    if (anchorElement instanceof HTMLElement) {
      this.updateAnchorElement(anchorElement);
    } else
    if (React.isValidElement(anchorElement)) {
      child = useWrapper ? React.createElement("span", null, anchorElement) : anchorElement;
    } else
    {
      child = React.createElement("span", null, anchorElement);
    }
    return React.createElement(RenderContainer_1["default"], { anchor: child, ref: child ? this.refAnchorElement : undefined }, location && this.renderContent(location));
  };
  Popup.prototype.extractElement = function (instance) {
    if (!instance) {
      return null;
    }
    var element = react_dom_1.findDOMNode(instance);
    return element instanceof HTMLElement ? element : null;
  };
  Popup.prototype.updateAnchorElement = function (element) {
    var anchorElement = this.anchorElement;
    if (element !== anchorElement) {
      this.removeEventListeners(anchorElement);
      this.anchorElement = element;
      this.addEventListeners(element);
    }
  };
  Popup.prototype.addEventListeners = function (element) {
    if (element && element instanceof HTMLElement) {
      element.addEventListener('mouseenter', this.handleMouseEnter);
      element.addEventListener('mouseleave', this.handleMouseLeave);
      element.addEventListener('click', this.handleClick);
      element.addEventListener('focusin', this.handleFocus);
      element.addEventListener('focusout', this.handleBlur);
    }
  };
  Popup.prototype.removeEventListeners = function (element) {
    if (element && element instanceof HTMLElement) {
      element.removeEventListener('mouseenter', this.handleMouseEnter);
      element.removeEventListener('mouseleave', this.handleMouseLeave);
      element.removeEventListener('click', this.handleClick);
      element.removeEventListener('focusin', this.handleFocus);
      element.removeEventListener('focusout', this.handleBlur);
    }
  };
  Popup.prototype.renderContent = function (location) {
    var _this = this;
    var _a = this.props,backgroundColor = _a.backgroundColor,disableAnimations = _a.disableAnimations,maxWidth = _a.maxWidth,hasShadow = _a.hasShadow,ignoreHover = _a.ignoreHover,opened = _a.opened;
    var children = this.renderChildren();
    var direction = PopupHelper_1["default"].getPositionObject(location.position).direction;
    var rootStyle = tslib_1.__assign({}, location.coordinates, { maxWidth: maxWidth });
    // This need to correct handle order of lifecycle hooks with portal and react@15
    // For more details see issue #1257
    return React.createElement(LifeCycleProxy_1["default"], { onDidUpdate: this.handleDidUpdate, props: this.state },
    React.createElement(react_transition_group_1.Transition, { timeout: TRANSITION_TIMEOUT, appear: !disableAnimations, "in": Boolean(opened && children), mountOnEnter: true, unmountOnExit: true, enter: !disableAnimations, exit: !disableAnimations, onExited: this.resetLocation }, function (state) {
      var _a, _b;
      return React.createElement(ZIndex_1["default"], { ref: _this.refPopupElement, priority: 'Popup', className: Emotion_1.cx([Popup_module_less_1["default"].popup, Popup_styles_1["default"].popup(_this.theme)], tslib_1.__assign((_a = {}, _a[Popup_styles_1["default"].shadow(_this.theme)] = hasShadow, _a[Popup_module_less_1["default"]['popup-ignore-hover']] = ignoreHover, _a), disableAnimations ?
        {} : (
        _b = {},
        _b[Popup_module_less_1["default"]['transition-enter']] = state === 'entering',
        _b[Popup_module_less_1["default"]['transition-enter-active']] = state === 'entered',
        _b[Popup_module_less_1["default"]['transition-exit']] = state === 'exiting',
        _b[Popup_module_less_1["default"]["transition-enter-" + direction]] = true,
        _b))), style: rootStyle, onMouseEnter: _this.handleMouseEnter, onMouseLeave: _this.handleMouseLeave },
      React.createElement("div", { className: Emotion_1.cx(Popup_module_less_1["default"].content, Popup_styles_1["default"].content(_this.theme)), "data-tid": 'PopupContent' },
      React.createElement("div", { className: Popup_styles_1["default"].contentInner(_this.theme), style: { backgroundColor: backgroundColor }, "data-tid": 'PopupContentInner' }, children)),
      _this.renderPin(location.position));
    }));
  };
  Popup.prototype.renderChildren = function () {
    return utils_1.isFunction(this.props.children) ? this.props.children() : this.props.children;
  };
  Popup.prototype.renderPin = function (position) {
    /**
                                                    * Box-shadow does not appear under the pin. Borders are used instead.
                                                    * In non-ie browsers drop-shadow filter is used. It is applying
                                                    * shadow to the pin too.
                                                    */
    var isDefaultBorderColor = this.theme.popupBorderColor === POPUP_BORDER_DEFAULT_COLOR;
    var pinBorder = ensureOldIEClassName_1.isIE && isDefaultBorderColor ? 'rgba(0, 0, 0, 0.09)' : this.theme.popupBorderColor;
    var _a = this.props,pinSize = _a.pinSize,pinOffset = _a.pinOffset,hasShadow = _a.hasShadow,backgroundColor = _a.backgroundColor,borderColor = _a.borderColor;
    return this.props.hasPin && React.createElement(PopupPin_1["default"], { popupElement: this.lastPopupElement, popupPosition: position, size: pinSize, offset: pinOffset, borderWidth: hasShadow ? 1 : 0, backgroundColor: backgroundColor || this.theme.popupBackground, borderColor: borderColor || pinBorder });
  };
  Popup.prototype.delayUpdateLocation = function () {
    this.cancelDelayedUpdateLocation();
    this.locationUpdateId = raf_1["default"](this.updateLocation);
  };
  Popup.prototype.cancelDelayedUpdateLocation = function () {
    if (this.locationUpdateId) {
      raf_1["default"].cancel(this.locationUpdateId);
      this.locationUpdateId = null;
    }
  };
  Popup.prototype.locationEquals = function (x, y) {
    if (x === y) {
      return true;
    }
    if (x == null || y == null) {
      return false;
    }
    return x.coordinates.left === y.coordinates.left && x.coordinates.top === y.coordinates.top && x.position === y.position;
  };
  Popup.prototype.getLocation = function (popupElement, location) {
    var positions = this.props.positions;
    var anchorElement = this.anchorElement;
    warning_1["default"](anchorElement && anchorElement instanceof HTMLElement, 'Anchor element is not defined or not instance of HTMLElement');
    if (!(anchorElement && anchorElement instanceof HTMLElement)) {
      return location;
    }
    var anchorRect = PopupHelper_1["default"].getElementAbsoluteRect(anchorElement);
    var popupRect = PopupHelper_1["default"].getElementAbsoluteRect(popupElement);
    var position;
    var coordinates;
    if (location && location !== DUMMY_LOCATION && location.position) {
      position = location.position;
      coordinates = this.getCoordinates(anchorRect, popupRect, position);
      var isFullyVisible = PopupHelper_1["default"].isFullyVisible(coordinates, popupRect);
      var canBecomeVisible = !isFullyVisible && PopupHelper_1["default"].canBecomeFullyVisible(position, coordinates);
      if (isFullyVisible || canBecomeVisible) {
        return { coordinates: coordinates, position: position };
      }
    }
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      position = positions_1[_i];
      coordinates = this.getCoordinates(anchorRect, popupRect, position);
      if (PopupHelper_1["default"].isFullyVisible(coordinates, popupRect)) {
        return { coordinates: coordinates, position: position };
      }
    }
    position = positions[0];
    coordinates = this.getCoordinates(anchorRect, popupRect, position);
    return { coordinates: coordinates, position: position };
  };
  Popup.prototype.getPinnedPopupOffset = function (anchorRect, position) {
    if (!this.props.hasPin || /center|middle/.test(position.align)) {
      return 0;
    }
    var anchorSize = /top|bottom/.test(position.direction) ? anchorRect.width : anchorRect.height;
    var _a = this.props,pinOffset = _a.pinOffset,pinSize = _a.pinSize;
    return Math.max(0, pinOffset + pinSize - anchorSize / 2);
  };
  Popup.prototype.getCoordinates = function (anchorRect, popupRect, positionName) {
    var margin = this.props.margin;
    var position = PopupHelper_1["default"].getPositionObject(positionName);
    var popupOffset = this.props.popupOffset + this.getPinnedPopupOffset(anchorRect, position);
    switch (position.direction) {
      case 'top':
        return {
          top: anchorRect.top - popupRect.height - margin,
          left: this.getHorizontalPosition(anchorRect, popupRect, position.align, popupOffset) };

      case 'bottom':
        return {
          top: anchorRect.top + anchorRect.height + margin,
          left: this.getHorizontalPosition(anchorRect, popupRect, position.align, popupOffset) };

      case 'left':
        return {
          top: this.getVerticalPosition(anchorRect, popupRect, position.align, popupOffset),
          left: anchorRect.left - popupRect.width - margin };

      case 'right':
        return {
          top: this.getVerticalPosition(anchorRect, popupRect, position.align, popupOffset),
          left: anchorRect.left + anchorRect.width + margin };

      default:
        throw new Error("Unxpected direction '" + position.direction + "'");}

  };
  Popup.prototype.getHorizontalPosition = function (anchorRect, popupRect, align, popupOffset) {
    switch (align) {
      case 'left':
        return anchorRect.left - popupOffset;
      case 'center':
        return anchorRect.left - (popupRect.width - anchorRect.width) / 2;
      case 'right':
        return anchorRect.left - (popupRect.width - anchorRect.width) + popupOffset;
      default:
        throw new Error("Unxpected align '" + align + "'");}

  };
  Popup.prototype.getVerticalPosition = function (anchorRect, popupRect, align, popupOffset) {
    switch (align) {
      case 'top':
        return anchorRect.top - popupOffset;
      case 'middle':
        return anchorRect.top - (popupRect.height - anchorRect.height) / 2;
      case 'bottom':
        return anchorRect.top - (popupRect.height - anchorRect.height) + popupOffset;
      default:
        throw new Error("Unxpected align '" + align + "'");}

  };
  Popup.__KONTUR_REACT_UI__ = 'Popup';
  Popup.propTypes = {
    /**
                       * Ссылка (ref) на элемент или React компонент, для которого рисуется попап
                       */
    anchorElement: PropTypes.oneOfType([safePropTypes.instanceOf(function () {return HTMLElement;}), PropTypes.node]).isRequired,
    /**
                                                                                                                                   * Фон попапа и пина
                                                                                                                                   */
    backgroundColor: PropTypes.string,
    children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
                                                                      * Показывать ли пин
                                                                      */
    hasPin: PropTypes.bool,
    /**
                             * Применять ли box-shadow на попапе. При false отключает границу на пине
                             */
    hasShadow: PropTypes.bool,
    /**
                                * Отступ попапа от элемента
                                */
    margin: PropTypes.number,
    /**
                               * Показан или скрыт попап
                               */
    opened: PropTypes.bool,
    /**
                             * Смещение пина от края попапа. Край задаётся в пропе position вторым словом
                             */
    pinOffset: PropTypes.number,
    /**
                                  * Сторона пина без учёта границы.
                                  * Пин представляет собой равносторонний треугольник, высота от попапа
                                  * до "носика" пина будет соответствовать формуле (size* √3)/2
                                  */
    pinSize: PropTypes.number,
    /**
                                * смещение попапа относительно родительского элемента
                                */
    popupOffset: PropTypes.number,
    /**
                                    * С какой стороны показывать попап и край попапа,
                                    * на котором будет отображаться пин
                                    */
    positions: PropTypes.array,
    /**
                                 * Игнорировать ли события hover/click
                                 */
    ignoreHover: PropTypes.bool };

  Popup.defaultProps = {
    margin: 10,
    popupOffset: 0,
    pinSize: 8,
    pinOffset: 16,
    hasPin: false,
    hasShadow: false,
    disableAnimations: Boolean(process.env.enableReactTesting),
    useWrapper: false,
    ignoreHover: false };

  return Popup;
}(React.Component);
exports["default"] = Popup;