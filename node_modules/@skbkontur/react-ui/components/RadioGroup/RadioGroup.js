"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var PropTypes = tslib_1.__importStar(require("prop-types"));
var invariant_1 = tslib_1.__importDefault(require("invariant"));
var v1_1 = tslib_1.__importDefault(require("uuid/v1"));
var Prevent_1 = tslib_1.__importDefault(require("./Prevent"));
var Radio_1 = tslib_1.__importDefault(require("../Radio"));
var RadioGroup_module_less_1 = tslib_1.__importDefault(require("./RadioGroup.module.css"));
var createPropsGetter_1 = require("../internal/createPropsGetter");
var Emotion_1 = require("../../lib/theming/Emotion");
var FocusTrap_1 = tslib_1.__importDefault(require("../internal/FocusTrap/FocusTrap"));
var RadioGroup = /** @class */function (_super) {
  tslib_1.__extends(RadioGroup, _super);
  function RadioGroup(props) {
    var _this = _super.call(this, props) || this;
    _this._name = v1_1["default"]();
    _this.getProps = createPropsGetter_1.createPropsGetter(RadioGroup.defaultProps);
    _this._getValue = function () {return _this._isControlled() ? _this.props.value : _this.state.activeItem;};
    _this._getName = function () {return _this.props.name || _this._name;};
    _this._isControlled = function () {return _this.props.value != null;};
    _this._handleSelect = function (event, value) {
      if (!_this._isControlled()) {
        _this.setState({ activeItem: value });
      }
      if (_this.props.onChange) {
        _this.props.onChange(event, value);
      }
    };
    _this._renderRadio = function (itemValue, data, index) {
      var _a;
      var itemProps = {
        key: typeof itemValue === 'string' || typeof itemValue === 'number' ? itemValue : index,
        className: Emotion_1.cx((_a = {},
        _a[RadioGroup_module_less_1["default"].item] = true,
        _a[RadioGroup_module_less_1["default"].itemFirst] = index === 0,
        _a[RadioGroup_module_less_1["default"].itemInline] = !!_this.props.inline,
        _a)) };

      return React.createElement("span", tslib_1.__assign({}, itemProps),
      React.createElement(Radio_1["default"], { value: itemValue }, _this.getProps().renderItem(itemValue, data)));
    };
    _this._ref = function (element) {
      _this.node = element;
    };
    _this.state = {
      activeItem: _this.props.defaultValue };

    return _this;
  }
  RadioGroup.prototype.getChildContext = function () {
    return {
      activeItem: this._getValue(),
      onSelect: this._handleSelect,
      name: this._getName(),
      disabled: this.props.disabled,
      error: this.props.error,
      warning: this.props.warning };

  };
  RadioGroup.prototype.render = function () {
    var _a = this.props,width = _a.width,onMouseLeave = _a.onMouseLeave,onMouseOver = _a.onMouseOver,onMouseEnter = _a.onMouseEnter,onBlur = _a.onBlur;
    var style = {
      width: width != null ? width : 'auto' };

    var handlers = {
      onMouseOver: onMouseOver,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave };

    return React.createElement(FocusTrap_1["default"], { onBlur: onBlur },
    React.createElement("span", tslib_1.__assign({ ref: this._ref, style: style, className: RadioGroup_module_less_1["default"].root }, handlers), this._renderChildren()));
  };
  /**
      * @public
      */
  RadioGroup.prototype.focus = function () {
    var node = this.node;
    if (!node) {
      return;
    }
    var radio = node.querySelector('input[type="radio"]:checked');
    // If no checked radios, try get first radio
    if (!radio || radio.disabled) {
      radio = node.querySelector('input[type="radio"]:not([disabled])');
    }
    if (radio) {
      radio.focus();
    }
  };
  RadioGroup.prototype._renderChildren = function () {
    var _a = this.props,items = _a.items,children = _a.children;
    invariant_1["default"](!items && children || items && !children, 'Either items or children must be passed, not both');
    return items ? mapItems(this._renderRadio, items) : children;
  };
  RadioGroup.__KONTUR_REACT_UI__ = 'RadioGroup';
  RadioGroup.childContextTypes = {
    error: PropTypes.bool,
    name: PropTypes.string,
    warning: PropTypes.bool,
    disabled: PropTypes.bool,
    activeItem: PropTypes.any,
    onSelect: PropTypes.func };

  RadioGroup.propTypes = {
    /**
                            * Может быть использовано, если не передан параметр `items`
                            *
                            * `children` может содержать любую разметку с компонентами Radio.
                            * Каждому компоненту Radio нужно указать параметр `value`, такого же типа
                            * как и параметр `value` самой радиогруппы.
                            *
                            * Значения активного элемента сравниваются по строгому равенству `===`
                            */
    children: PropTypes.node,
    /**
                               * Значение по умолчанию. Должно быть одним из значений дочерних радиокнопок
                               * или значей из параметра `items`
                               */
    defaultValue: PropTypes.any,
    /**
                                  * Дизейблит все радиокнопки
                                  */
    disabled: PropTypes.bool,
    /**
                               * Переводит все радиокнопки в состоянии ошибки
                               */
    error: PropTypes.bool,
    /**
                            * Выравнивает элементы в строку. Не работает с `children`
                            */
    inline: PropTypes.bool,
    /**
                             * Может быть использовано, если не передан параметр `children`
                             *
                             * Массив параметров радиокнопок. Может быть типа `Array<Value>` или
                             * `Array<[Value, Data]>`, где тип `Value` — значение радиокнопки, а `Data`
                             * — значение которое будет использовано вторым параметром в `renderItem`.
                             * Если тип `items: Array<Value>`, то он будет приведен к типу
                             * `Array<[Value, Value]>`
                             */
    items: PropTypes.any,
    /**
                           * Аттрибут name для вложенных радиокнопок. Если не указан, то сгенерируется
                           * случайное имя по алгоритму
                           * [uuid v1](https://github.com/kelektiv/node-uuid#version-1)
                           */
    name: PropTypes.string,
    /**
                             * Метод отрисовки контента радиокнопки. Не работает с `children`.
                             *
                             * Принимает два аргумента: `(value: Value, data: Data) => React.Node`
                             */
    renderItem: PropTypes.func,
    /**
                                 * Значение радиогруппы. Должно быть одним из значений радиокнопок.
                                 * Если не указано, то компонент будет работать, как неконтроллируемый
                                 */
    value: PropTypes.any,
    /**
                           * Переводит все радиокнопки в состоянии предупреждения
                           */
    warning: PropTypes.bool,
    /**
                              * Ширина радиогруппы. Не работает с `children`
                              */
    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
    /**
                                                                       * Обработчик события при переключении радиокнопок.
                                                                       * Имеет тип
                                                                       * `(event: SyntheticInputEvent<HTMLInputElement>, value: Value) => any`
                                                                       */
    onChange: PropTypes.func,
    onBlur: PropTypes.func,
    onMouseEnter: PropTypes.func,
    onMouseLeave: PropTypes.func,
    onMouseOver: PropTypes.func };

  RadioGroup.defaultProps = {
    renderItem: renderItem };

  RadioGroup.Prevent = Prevent_1["default"];
  return RadioGroup;
}(React.Component);
exports["default"] = RadioGroup;
function renderItem(_value, data) {
  return data;
}
function mapItems(fn, items) {
  var result = [];
  var index = 0;
  for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
    var entry = items_1[_i];
    var _a = normalizeEntry(entry),value = _a[0],data = _a[1];
    result.push(fn(value, data, index));
    ++index;
  }
  return result;
}
function normalizeEntry(entry) {
  if (!Array.isArray(entry)) {
    return [entry, entry];
  }
  return entry;
}