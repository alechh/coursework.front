"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var warning_1 = tslib_1.__importDefault(require("warning"));
var lodash_debounce_1 = tslib_1.__importDefault(require("lodash.debounce"));
var lodash_isequal_1 = tslib_1.__importDefault(require("lodash.isequal"));
var identifiers_1 = require("../../lib/events/keyboard/identifiers");
var CustomComboBox_1 = require("./CustomComboBox");
var LayoutEvents_1 = tslib_1.__importDefault(require("../../lib/LayoutEvents"));
var CustomComboBoxTypes_1 = require("./CustomComboBoxTypes");
var DEBOUNCE_DELAY = 300;
var getValueString = function getValueString(value, valueToString) {
  return value ? valueToString(value) : '';
};
exports.Effect = {
  Search: function Search(query) {return function (dispatch, getState, getProps, getInstance) {
      getInstance().search(query);
    };},
  DebouncedSearch: lodash_debounce_1["default"](function (dispatch, getState, getProps, getInstance) {
    var searchEffect = exports.Effect.Search(getState().textValue);
    searchEffect(dispatch, getState, getProps, getInstance);
  }, DEBOUNCE_DELAY),
  CancelRequest: function CancelRequest(dispatch, getState, getProps, getInstance) {
    getInstance().cancelSearch();
  },
  Blur: function Blur(dispatch, getState, getProps) {
    var onBlur = getProps().onBlur;
    exports.Effect.DebouncedSearch.cancel();
    if (onBlur) {
      onBlur();
    }
  },
  Focus: function Focus(dispatch, getState, getProps) {
    var onFocus = getProps().onFocus;
    if (onFocus) {
      onFocus();
    }
  },
  Change: function Change(value) {return function (dispatch, getState, getProps) {
      var onChange = getProps().onChange;
      if (onChange) {
        onChange({ target: { value: value } }, value);
      }
    };},
  UnexpectedInput: function UnexpectedInput(textValue, items) {return function (dispatch, getState, getProps) {
      var _a = getProps(),onUnexpectedInput = _a.onUnexpectedInput,valueToString = _a.valueToString;
      if (Array.isArray(items) && items.length === 1) {
        var singleItem = items[0];
        var valueContent = getValueString(singleItem, valueToString);
        if (valueContent === textValue) {
          dispatch({ type: 'ValueChange', value: singleItem, keepFocus: false });
          return;
        }
      }
      if (onUnexpectedInput) {
        // NOTE Обсудить поведение onUnexpectedInput
        var value = onUnexpectedInput(textValue);
        if (value === null) {
          warning_1["default"](false, "[ComboBox] Returning 'null' is deprecated in 'onUnexpectedInput'. For clear value use instance method 'reset'");
          dispatch({ type: 'TextClear' });
        } else
        if (value !== undefined) {
          dispatch({ type: 'ValueChange', value: value, keepFocus: false });
        }
      }
    };},
  InputChange: function InputChange(dispatch, getState, getProps) {
    var onInputChange = getProps().onInputChange;
    var textValue = getState().textValue;
    if (onInputChange) {
      var returnedValue = onInputChange(textValue);
      if (typeof returnedValue === 'string' && returnedValue !== textValue) {
        dispatch({ type: 'TextChange', value: returnedValue });
      }
    }
  },
  InputFocus: function InputFocus(dispatch, getState, getProps, getInstance) {
    var input = getInstance().input;
    if (!input) {
      return;
    }
    input.focus();
  },
  HighlightMenuItem: function HighlightMenuItem(dispatch, getState, getProps, getInstance) {
    var _a = getProps(),value = _a.value,itemToValue = _a.itemToValue,valueToString = _a.valueToString;
    var _b = getState(),items = _b.items,focused = _b.focused,textValue = _b.textValue,requestStatus = _b.requestStatus;
    var menu = getInstance().menu;
    var valueString = getValueString(value, valueToString);
    if (!menu) {
      return;
    }
    if (!focused) {
      return;
    }
    var index = -1;
    if (items && items.length && value) {
      index = items.findIndex(function (x) {return itemToValue(x) === itemToValue(value);});
    }
    menu.highlightItem(index);
    if (index >= 0) {
      // FIXME: accessing private props
      // @ts-ignore
      process.nextTick(function () {return menu && menu.scrollToSelected();});
      return;
    }
    if (textValue !== valueString || requestStatus === CustomComboBoxTypes_1.ComboBoxRequestStatus.Failed) {
      process.nextTick(function () {return menu && menu.down();});
    }
  },
  SelectMenuItem: function SelectMenuItem(event) {return function (dispatch, getState, getProps, getInstance) {
      var menu = getInstance().menu;
      if (menu) {
        menu.enter(event);
      }
    };},
  MoveMenuHighlight: function MoveMenuHighlight(direction) {return function (dispatch, getState, getProps, getInstance) {
      var menu = getInstance().menu;
      if (menu) {
        menu[direction]();
      }
    };},
  ResetHighlightedMenuItem: function ResetHighlightedMenuItem(dispatch, getState, getProps, getInstance) {
    var combobox = getInstance();
    if (combobox.menu && combobox.menu.hasHighlightedItem()) {
      combobox.menu.reset();
    }
  },
  Reflow: function Reflow() {
    LayoutEvents_1["default"].emit();
  },
  SelectInputText: function SelectInputText(dispatch, getState, getProps, getInstance) {
    var combobox = getInstance();
    combobox.selectInputText();
  },
  InputKeyDown: function InputKeyDown(event) {return function (dispatch, getState, getProps, getInstance) {
      var onInputKeyDown = getProps().onInputKeyDown;
      if (onInputKeyDown) {
        onInputKeyDown(event);
      }
    };} };

var never = function never(_) {return null;};
function reducer(state, props, action) {
  switch (action.type) {
    case 'TextClear':{
        return { textValue: '' };
      }
    case 'ValueChange':{
        var value = action.value,keepFocus = action.keepFocus;
        var textValue = getValueString(value, props.valueToString);
        if (keepFocus) {
          return [
          {
            opened: false,
            inputChanged: false,
            editing: true,
            items: null,
            textValue: textValue },

          [exports.Effect.Change(value), exports.Effect.CancelRequest, exports.Effect.InputFocus]];

        }
        return [
        {
          opened: false,
          inputChanged: false,
          editing: false,
          items: null,
          textValue: textValue },

        [exports.Effect.Change(value), exports.Effect.CancelRequest]];

      }
    case 'TextChange':{
        var newState = {
          inputChanged: true,
          textValue: action.value };

        if (!action.value && !props.searchOnFocus) {
          return [
          tslib_1.__assign({}, newState, { opened: false, items: null }),
          [exports.Effect.InputChange]];

        }
        return [newState, [exports.Effect.DebouncedSearch, exports.Effect.InputChange]];
      }
    case 'KeyPress':{
        var e = action.event;
        var effects = [];
        var nextState = state;
        switch (true) {
          case identifiers_1.isKeyEnter(e):
            e.preventDefault();
            effects.push(exports.Effect.SelectMenuItem(e));
            break;
          case identifiers_1.isKeyArrowVertical(e):
            e.preventDefault();
            effects.push(exports.Effect.MoveMenuHighlight(identifiers_1.isKeyArrowUp(e) ? 'up' : 'down'));
            if (!state.opened) {
              effects.push(exports.Effect.Search(state.textValue));
            }
            break;
          case identifiers_1.isKeyEscape(e):
            nextState = tslib_1.__assign({}, state, { items: null, opened: false });
            break;}

        return [nextState, effects.concat([exports.Effect.InputKeyDown(e)])];
      }
    case 'DidUpdate':{
        if (lodash_isequal_1["default"](props.value, action.prevProps.value)) {
          return state;
        }
        return {
          opened: false,
          textValue: state.editing ? state.textValue : getValueString(props.value, props.valueToString) };

      }
    case 'Mount':{
        return {
          textValue: getValueString(props.value, props.valueToString) };

      }
    case 'Focus':{
        var newState = {
          focused: true,
          editing: true };

        if (!props.searchOnFocus) {
          return [newState, [exports.Effect.Focus]];
        }
        if (state.editing) {
          return [newState, [exports.Effect.Search(state.textValue), exports.Effect.Focus]];
        }
        return [newState, [exports.Effect.Search(''), exports.Effect.Focus, exports.Effect.SelectInputText]];
      }
    case 'InputClick':{
        if (!state.opened && props.searchOnFocus) {
          return [state, [exports.Effect.Search('')]];
        }
        return state;
      }
    case 'Blur':{
        var inputChanged = state.inputChanged,items = state.items;
        if (!inputChanged) {
          return [
          {
            focused: false,
            opened: false,
            items: null,
            editing: false },

          [exports.Effect.Blur, exports.Effect.CancelRequest]];

        }
        return [
        {
          focused: false,
          opened: false,
          items: null },

        [exports.Effect.Blur, exports.Effect.CancelRequest, exports.Effect.UnexpectedInput(state.textValue, items)]];

      }
    case 'Reset':{
        return CustomComboBox_1.DefaultState;
      }
    case 'Open':{
        return { opened: true };
      }
    case 'Close':{
        return { opened: false, items: null };
      }
    case 'Search':{
        return [state, [exports.Effect.Search(action.query)]];
      }
    case 'RequestItems':{
        return {
          loading: true,
          opened: true,
          requestStatus: CustomComboBoxTypes_1.ComboBoxRequestStatus.Pending };

      }
    case 'ReceiveItems':{
        var shouldResetMenuHighlight = state.textValue === '';
        return [
        {
          loading: false,
          opened: true,
          items: action.items,
          requestStatus: CustomComboBoxTypes_1.ComboBoxRequestStatus.Success },

        [shouldResetMenuHighlight ? exports.Effect.ResetHighlightedMenuItem : exports.Effect.HighlightMenuItem, exports.Effect.Reflow]];

      }
    case 'RequestFailure':{
        return [
        {
          loading: false,
          opened: true,
          items: null,
          requestStatus: CustomComboBoxTypes_1.ComboBoxRequestStatus.Failed,
          repeatRequest: action.repeatRequest },

        [exports.Effect.HighlightMenuItem]];

      }
    case 'CancelRequest':{
        return {
          loading: false,
          requestStatus: CustomComboBoxTypes_1.ComboBoxRequestStatus.Unknown };

      }
    default:{
        never(action);
      }}

  return state;
}
exports.reducer = reducer;