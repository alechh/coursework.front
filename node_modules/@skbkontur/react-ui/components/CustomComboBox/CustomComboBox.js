"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var ComboBoxView_1 = tslib_1.__importDefault(require("./ComboBoxView"));
var CustomComboBoxTypes_1 = require("./CustomComboBoxTypes");
var utils_1 = require("../../lib/utils");
var CustomComboBoxReducer_1 = require("./CustomComboBoxReducer");
var fixClickFocusIE_1 = require("../../lib/events/fixClickFocusIE");
exports.DELAY_BEFORE_SHOW_LOADER = 300;
exports.LOADER_SHOW_TIME = 1000;
exports.DefaultState = {
  inputChanged: false,
  editing: false,
  items: null,
  loading: false,
  opened: false,
  focused: false,
  textValue: '',
  repeatRequest: function repeatRequest() {return undefined;},
  requestStatus: CustomComboBoxTypes_1.ComboBoxRequestStatus.Unknown };

var CustomComboBox = /** @class */function (_super) {
  tslib_1.__extends(CustomComboBox, _super);
  function CustomComboBox() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = exports.DefaultState;
    _this.requestId = 0;
    _this.focused = false;
    _this.cancelationToken = null;
    _this.reducer = CustomComboBoxReducer_1.reducer;
    _this.cancelLoaderDelay = function () {return null;};
    /**
                                                           * @public
                                                           */
    _this.focus = function () {
      if (_this.props.disabled) {
        return;
      }
      _this.handleFocus();
    };
    /**
        * @public
        */
    _this.selectInputText = function () {
      if (_this.props.disabled) {
        return;
      }
      if (_this.input) {
        _this.input.selectAll();
      }
    };
    /**
        * @public
        */
    _this.blur = function () {
      if (_this.props.disabled) {
        return;
      }
      _this.handleBlur();
    };
    _this.dispatch = function (action) {
      var effects;
      var nextState;
      _this.setState(function (state) {
        var _a;
        var stateAndEffect = _this.reducer(state, _this.props, action);
        _a = stateAndEffect instanceof Array ? stateAndEffect : [stateAndEffect, []], nextState = _a[0], effects = _a[1];
        return nextState;
      }, function () {
        effects.forEach(_this.handleEffect);
      });
    };
    _this.handleEffect = function (effect) {
      effect(_this.dispatch, _this.getState, _this.getProps, function () {return _this;});
    };
    _this.getProps = function () {return _this.props;};
    _this.getState = function () {return _this.state;};
    _this.handleChange = function (value) {
      _this.dispatch({
        type: 'ValueChange',
        value: value,
        keepFocus: true });

    };
    _this.handleFocus = function () {
      if (_this.focused) {
        return;
      }
      _this.focused = true;
      _this.dispatch({ type: 'Focus' });
    };
    _this.handleClickOutside = function (e) {
      fixClickFocusIE_1.fixClickFocusIE(e);
      _this.handleBlur();
    };
    _this.handleBlur = function () {
      if (!_this.focused) {
        if (_this.state.opened) {
          _this.close();
        }
        return;
      }
      _this.focused = false;
      _this.dispatch({ type: 'Blur' });
    };
    _this.handleInputBlur = function () {
      // If menu opened, RenderLayer is active and
      // it would call handleFocusOutside
      // In that way handleBlur would be called
      if (_this.state.opened) {
        return;
      }
      _this.handleBlur();
    };
    _this.handleInputClick = function () {
      if (!_this.cancelationToken) {
        _this.dispatch({ type: 'InputClick' });
      }
    };
    return _this;
  }
  /**
     * @public
     */
  CustomComboBox.prototype.search = function (query) {
    if (query === void 0) {query = this.state.textValue;}
    return tslib_1.__awaiter(this, void 0, void 0, function () {
      var getItems, cancelPromise, expectingId, items, error_1;
      var _this = this;
      return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            getItems = this.props.getItems;
            cancelPromise = new Promise(function (_, reject) {return _this.cancelationToken = reject;});
            expectingId = this.requestId += 1;
            if (!this.loaderShowDelay) {
              this.loaderShowDelay = new Promise(function (resolve) {
                var cancelLoader = utils_1.taskWithDelay(function () {
                  _this.dispatch({ type: 'RequestItems' });
                  setTimeout(resolve, exports.LOADER_SHOW_TIME);
                }, exports.DELAY_BEFORE_SHOW_LOADER);
                cancelPromise["catch"](function () {return cancelLoader();});
                _this.cancelLoaderDelay = function () {
                  cancelLoader();
                  resolve();
                };
              });
            }
            _a.label = 1;
          case 1:
            _a.trys.push([1, 5, 6, 7]);
            return [4 /*yield*/, Promise.race([getItems(query) || [], cancelPromise])];
          case 2:
            items = _a.sent();
            if (!this.state.loading) return [3 /*break*/, 4];
            return [4 /*yield*/, Promise.race([this.loaderShowDelay, cancelPromise])];
          case 3:
            _a.sent();
            _a.label = 4;
          case 4:
            if (expectingId === this.requestId) {
              this.dispatch({
                type: 'ReceiveItems',
                items: items });

            }
            return [3 /*break*/, 7];
          case 5:
            error_1 = _a.sent();
            if (error_1 && error_1.code === 'CancelationError') {
              this.dispatch({ type: 'CancelRequest' });
            } else
            if (expectingId === this.requestId) {
              this.dispatch({
                type: 'RequestFailure',
                repeatRequest: function repeatRequest() {
                  _this.search(query);
                  if (_this.input) {
                    _this.input.focus();
                  }
                } });

            }
            return [3 /*break*/, 7];
          case 6:
            if (expectingId === this.requestId) {
              if (!this.state.loading) {
                this.cancelLoaderDelay();
              }
              this.cancelationToken = null;
              this.loaderShowDelay = null;
            }
            return [7 /*endfinally*/];
          case 7:return [2 /*return*/];}

      });
    });
  };
  /**
      * @public
      */
  CustomComboBox.prototype.cancelSearch = function () {
    if (this.cancelationToken) {
      this.cancelationToken(new utils_1.CancelationError());
    }
  };
  /**
      * @public
      */
  CustomComboBox.prototype.open = function () {
    this.dispatch({ type: 'Open' });
  };
  /**
      * @public
      */
  CustomComboBox.prototype.close = function () {
    this.dispatch({ type: 'Close' });
  };
  CustomComboBox.prototype.render = function () {
    var _this = this;
    var viewProps = {
      align: this.props.align,
      borderless: this.props.borderless,
      disabled: this.props.disabled,
      disablePortal: this.props.disablePortal,
      editing: this.state.editing,
      error: this.props.error,
      items: this.state.items,
      loading: this.state.loading,
      menuAlign: this.props.menuAlign,
      opened: this.state.opened,
      drawArrow: this.props.drawArrow,
      placeholder: this.props.placeholder,
      size: this.props.size,
      textValue: this.state.textValue,
      totalCount: this.props.totalCount,
      value: this.props.value,
      warning: this.props.warning,
      width: this.props.width,
      maxLength: this.props.maxLength,
      maxMenuHeight: this.props.maxMenuHeight,
      onChange: this.handleChange,
      onClickOutside: this.handleClickOutside,
      onFocus: this.handleFocus,
      onFocusOutside: this.handleBlur,
      onInputBlur: this.handleInputBlur,
      onInputChange: function onInputChange(_, value) {
        return _this.dispatch({ type: 'TextChange', value: value });
      },
      onInputFocus: this.handleFocus,
      onInputClick: this.handleInputClick,
      onInputKeyDown: function onInputKeyDown(event) {
        event.persist();
        _this.dispatch({ type: 'KeyPress', event: event });
      },
      onMouseEnter: this.props.onMouseEnter,
      onMouseOver: this.props.onMouseOver,
      onMouseLeave: this.props.onMouseLeave,
      renderItem: this.props.renderItem,
      renderNotFound: this.props.renderNotFound,
      renderValue: this.props.renderValue,
      renderTotalCount: this.props.renderTotalCount,
      renderAddButton: this.props.renderAddButton,
      repeatRequest: this.state.repeatRequest,
      requestStatus: this.state.requestStatus,
      refInput: function refInput(input) {
        _this.input = input;
      },
      refMenu: function refMenu(menu) {
        _this.menu = menu;
      },
      refInputLikeText: function refInputLikeText(inputLikeText) {
        _this.inputLikeText = inputLikeText;
      } };

    return React.createElement(ComboBoxView_1["default"], tslib_1.__assign({}, viewProps));
  };
  CustomComboBox.prototype.componentDidMount = function () {
    this.dispatch({ type: 'Mount' });
    if (this.props.autoFocus) {
      this.focus();
    }
  };
  CustomComboBox.prototype.componentDidUpdate = function (prevProps, prevState) {
    if (prevState.editing && !this.state.editing) {
      this.handleBlur();
    }
    this.dispatch({ type: 'DidUpdate', prevProps: prevProps, prevState: prevState });
  };
  /**
      * @public
      */
  CustomComboBox.prototype.reset = function () {
    this.dispatch({ type: 'Reset' });
  };
  CustomComboBox.__KONTUR_REACT_UI__ = 'CustomComboBox';
  return CustomComboBox;
}(React.PureComponent);
exports["default"] = CustomComboBox;