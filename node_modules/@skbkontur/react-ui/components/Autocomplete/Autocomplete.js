"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var PropTypes = tslib_1.__importStar(require("prop-types"));
var react_dom_1 = require("react-dom");
var identifiers_1 = require("../../lib/events/keyboard/identifiers");
var Input_1 = tslib_1.__importDefault(require("../Input"));
var DropdownContainer_1 = tslib_1.__importDefault(require("../DropdownContainer/DropdownContainer"));
var Menu_1 = tslib_1.__importDefault(require("../Menu/Menu"));
var MenuItem_1 = tslib_1.__importDefault(require("../MenuItem"));
var RenderLayer_1 = tslib_1.__importDefault(require("../RenderLayer"));
var createPropsGetter_1 = require("../internal/createPropsGetter");
var fixClickFocusIE_1 = require("../../lib/events/fixClickFocusIE");
/**
                                                                      * Стандартный инпут с подсказками.
                                                                      *
                                                                      * Все свойства передаются во внутренний *Input*.
                                                                      */
var Autocomplete = /** @class */function (_super) {
  tslib_1.__extends(Autocomplete, _super);
  function Autocomplete() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      items: null,
      selected: -1 };

    _this.opened = false;
    _this.input = null;
    _this.focused = false;
    _this.requestId = 0;
    _this.getProps = createPropsGetter_1.createPropsGetter(Autocomplete.defaultProps);
    _this.handleChange = function (event) {
      _this.opened = true;
      // https://github.com/airbnb/enzyme/issues/218
      // TODO: replace with currentTarget when fixed
      var value = event.target.value;
      _this.fireChange(value);
    };
    _this.handleFocus = function (event) {
      if (_this.focused) {
        return;
      }
      _this.focused = true;
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };
    _this.handleBlur = function () {
      if (!_this.focused) {
        return;
      }
      _this.focused = false;
      _this.opened = false;
      _this.setState({ items: null });
      if (_this.input) {
        _this.input.blur();
      }
      if (_this.props.onBlur) {
        _this.props.onBlur();
      }
    };
    _this.handleClickOutside = function (e) {
      fixClickFocusIE_1.fixClickFocusIE(e);
      _this.handleBlur();
    };
    _this.handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }
      switch (true) {
        case identifiers_1.isKeyEscape(e):
          e.preventDefault();
          _this.setState({ items: null });
          return;
        case identifiers_1.isKeyArrowUp(e):
          e.preventDefault();
          if (_this.menu) {
            _this.menu.up();
          }
          return;
        case identifiers_1.isKeyArrowDown(e):
          e.preventDefault();
          if (_this.menu) {
            _this.menu.down();
          }
          return;
        case identifiers_1.isKeyEnter(e):
          e.preventDefault(); // To prevent form submission.
          if (_this.menu) {
            _this.menu.enter(e);
          }
          return;}

    };
    _this.getAnchor = function () {
      return react_dom_1.findDOMNode(_this);
    };
    _this.refInput = function (el) {
      _this.input = el;
    };
    _this.refMenu = function (menu) {
      _this.menu = menu;
    };
    return _this;
  }
  /**
     * @public
     */
  Autocomplete.prototype.focus = function () {
    if (this.input) {
      this.input.focus();
    }
  };
  /**
      * @public
      */
  Autocomplete.prototype.blur = function () {
    this.handleBlur();
  };
  Autocomplete.prototype.componentDidUpdate = function (prevProps) {
    if (prevProps.value !== this.props.value) {
      this.updateItems(this.props.value || '');
    }
  };
  Autocomplete.prototype.render = function () {
    var _a = this.props,onChange = _a.onChange,onKeyDown = _a.onKeyDown,onFocus = _a.onFocus,onBlur = _a.onBlur,_renderItem = _a.renderItem,disablePortal = _a.disablePortal,hasShadow = _a.hasShadow,menuAlign = _a.menuAlign,menuMaxHeight = _a.menuMaxHeight,preventWindowScroll = _a.preventWindowScroll,source = _a.source,rest = tslib_1.__rest(_a, ["onChange", "onKeyDown", "onFocus", "onBlur", "renderItem", "disablePortal", "hasShadow", "menuAlign", "menuMaxHeight", "preventWindowScroll", "source"]);
    var inputProps = tslib_1.__assign({}, rest, { onChange: this.handleChange, onKeyDown: this.handleKeyDown, onFocus: this.handleFocus, ref: this.refInput });
    return React.createElement(RenderLayer_1["default"], { onFocusOutside: this.handleBlur, onClickOutside: this.handleClickOutside },
    React.createElement("span", { style: { display: 'inline-block' } },
    React.createElement(Input_1["default"], tslib_1.__assign({}, inputProps)),
    this.renderMenu()));
  };
  Autocomplete.prototype.renderMenu = function () {
    var _this = this;
    var items = this.state.items;
    var menuProps = {
      ref: this.refMenu,
      maxHeight: this.props.menuMaxHeight,
      hasShadow: this.props.hasShadow,
      width: this.props.menuWidth || this.props.width,
      preventWindowScroll: this.props.preventWindowScroll };

    if (!items || items.length === 0) {
      return null;
    }
    return React.createElement(DropdownContainer_1["default"], { offsetY: 1, getParent: this.getAnchor, align: this.props.menuAlign, disablePortal: this.props.disablePortal },
    React.createElement(Menu_1["default"], tslib_1.__assign({}, menuProps), items.map(function (item, i) {
      return React.createElement(MenuItem_1["default"], { onClick: _this.handleMenuItemClick(i), key: i }, _this.getProps().renderItem(item));
    })));
  };
  Autocomplete.prototype.handleMenuItemClick = function (i) {
    var _this = this;
    return function (event) {return _this.handleItemClick(event, i);};
  };
  Autocomplete.prototype.handleItemClick = function (event, index) {
    if (event.button) {
      return;
    }
    event.preventDefault();
    this.choose(index);
  };
  Autocomplete.prototype.choose = function (index) {
    if (!this.state.items) {
      return;
    }
    var value = this.state.items[index];
    this.opened = false;
    this.setState({
      selected: -1,
      items: null });

    this.fireChange(value);
    this.blur();
  };
  Autocomplete.prototype.updateItems = function (value) {
    var _this = this;
    if (!this.opened) {
      return;
    }
    var pattern = value.trim();
    var source = this.props.source;
    if (!source) {
      return;
    }
    var promise;
    var expectingId = this.requestId += 1;
    if (typeof source === 'function') {
      promise = source(pattern);
    } else
    {
      promise = match(pattern, source);
    }
    promise.then(function (items) {
      if (_this.opened && expectingId === _this.requestId) {
        _this.setState({
          items: items,
          selected: -1 });

      }
    });
  };
  Autocomplete.prototype.fireChange = function (value) {
    if (this.props.onChange) {
      this.props.onChange({ target: { value: value } }, value);
    }
  };
  Autocomplete.__KONTUR_REACT_UI__ = 'Autocomplete';
  Autocomplete.propTypes = {
    /**
                              * Функция для отрисовки элемента в выпадающем списке. Единственный аргумент
                              * — *item*.
                              */
    renderItem: PropTypes.func,
    /**
                                 * Если передан массив, то совпадения ищутся по этому массиву.
                                 *
                                 * Если передается функция, то она должна возвращать thenable, который
                                 * резолвится уже отфильтрованным массивом. Возвращенный thenable может
                                 * иметь метод cancel, который будет вызван при отмене поиска (пользователь
                                 * изменил строку поиска, автокомплит потерял фокус).
                                 * ```
                                 * function(pattern) {
                                 *   return service.findAll(pattern);
                                 * }
                                 * ```
                                 */
    source: PropTypes.oneOfType([PropTypes.array, PropTypes.func]) };

  Autocomplete.defaultProps = {
    renderItem: renderItem,
    size: 'small',
    disablePortal: false,
    hasShadow: true,
    menuMaxHeight: 300,
    menuAlign: 'left',
    preventWindowScroll: true };

  return Autocomplete;
}(React.Component);
function match(pattern, items) {
  if (!pattern || !items) {
    return Promise.resolve([]);
  }
  pattern = pattern.toLowerCase();
  var filteredItems = items.filter(function (item) {return item.toLowerCase().includes(pattern);});
  return Promise.resolve(filteredItems);
}
function renderItem(item) {
  return item;
}
exports["default"] = Autocomplete;