"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var PropTypes = tslib_1.__importStar(require("prop-types"));
var LayoutEvents_1 = tslib_1.__importDefault(require("../../lib/LayoutEvents"));
var getScrollWidth_1 = tslib_1.__importDefault(require("../../lib/dom/getScrollWidth"));
var ScrollContainer_module_less_1 = tslib_1.__importDefault(require("./ScrollContainer.module.css"));
var utils_1 = require("../../lib/utils");
var Emotion_1 = require("../../lib/theming/Emotion");
var PADDING_RIGHT = 30;
var MIN_SCROLL_SIZE = 20;
var SCROLL_HIDDEN = utils_1.isChrome || utils_1.isOpera || utils_1.isSafari;
var ScrollContainer = /** @class */function (_super) {
  tslib_1.__extends(ScrollContainer, _super);
  function ScrollContainer() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      scrollActive: false,
      scrollSize: 0,
      scrollPos: 0,
      // Mouse is moving where big scrollbar can be located.
      hover: false,
      // True when scroll is following mouse (mouse down on scroll).
      scrolling: false,
      scrollState: 'top' };

    _this.refInner = function (element) {
      if (!_this.inner && element && _this.props.preventWindowScroll) {
        element.addEventListener('wheel', _this.handleInnerScrollWheel, { passive: false });
      }
      if (_this.inner && !element) {
        _this.inner.removeEventListener('wheel', _this.handleInnerScrollWheel);
      }
      _this.inner = element;
    };
    _this.refScroll = function (element) {
      if (!_this.scroll && element) {
        element.addEventListener('wheel', _this.handleScrollWheel, { passive: false });
      }
      if (_this.scroll && !element) {
        _this.scroll.removeEventListener('wheel', _this.handleScrollWheel);
      }
      _this.scroll = element;
    };
    _this.handleNativeScroll = function (event) {
      _this.reflow();
      if (_this.props.preventWindowScroll) {
        event.preventDefault();
        return;
      }
      LayoutEvents_1["default"].emit();
    };
    _this.reflow = function () {
      if (!_this.inner) {
        return;
      }
      var containerHeight = _this.inner.offsetHeight;
      var contentHeight = _this.inner.scrollHeight;
      var scrollTop = _this.inner.scrollTop;
      var scrollActive = containerHeight < contentHeight;
      if (!scrollActive && !_this.state.scrollActive) {
        return;
      }
      if (scrollActive) {
        var scrollSize = containerHeight / contentHeight * containerHeight;
        if (scrollSize < MIN_SCROLL_SIZE) {
          scrollSize = MIN_SCROLL_SIZE;
        }
        var scrollPos = scrollTop / (contentHeight - containerHeight) * (containerHeight - scrollSize);
        if (_this.state.scrollSize !== scrollSize || _this.state.scrollPos !== scrollPos) {
          var scrollState = _this.state.scrollState;
          var updatedScrollState = _this.getImmediateScrollState();
          var scrollParamsToUpdate = {
            scrollActive: true,
            scrollSize: scrollSize,
            scrollPos: scrollPos,
            scrollState: scrollState };

          if (updatedScrollState !== _this.state.scrollState) {
            scrollParamsToUpdate.scrollState = updatedScrollState;
            if (_this.props.onScrollStateChange) {
              _this.props.onScrollStateChange(updatedScrollState);
            }
          }
          _this.setState(scrollParamsToUpdate);
        }
      } else
      {
        _this.setState({
          scrollActive: false,
          scrollSize: 0,
          scrollPos: 0 });

      }
    };
    _this.handleScrollMouseDown = function (event) {
      if (!_this.inner) {
        return;
      }
      var target = window.document;
      var initialY = event.clientY;
      var initialScrollTop = _this.inner.scrollTop;
      var mouseMove = function mouseMove(mouseMoveEvent) {
        if (!_this.inner) {
          return;
        }
        var ratio = (_this.inner.scrollHeight - _this.inner.offsetHeight) / (_this.inner.offsetHeight - _this.state.scrollSize);
        var deltaY = (mouseMoveEvent.clientY - initialY) * ratio;
        _this.inner.scrollTop = initialScrollTop + deltaY;
        if (mouseMoveEvent.preventDefault) {
          mouseMoveEvent.preventDefault();
        }
        if (mouseMoveEvent.hasOwnProperty('returnValue')) {
          mouseMoveEvent.returnValue = false;
        }
      };
      var mouseUp = function mouseUp() {
        target.removeEventListener('mousemove', mouseMove);
        target.removeEventListener('mouseup', mouseUp);
        _this.setState({ scrolling: false });
      };
      target.addEventListener('mousemove', mouseMove);
      target.addEventListener('mouseup', mouseUp);
      _this.setState({ scrolling: true });
      event.preventDefault();
    };
    _this.handleScrollWheel = function (event) {
      if (!_this.inner || !(event instanceof WheelEvent)) {
        return;
      }
      if (event.deltaY > 0 && _this.inner.scrollHeight <= _this.inner.scrollTop + _this.inner.offsetHeight) {
        return;
      }
      if (event.deltaY < 0 && _this.inner.scrollTop <= 0) {
        return;
      }
      _this.inner.scrollTop += event.deltaY;
      event.preventDefault();
    };
    _this.handleInnerScrollWheel = function (event) {
      if (!_this.inner || !(event instanceof WheelEvent)) {
        return;
      }
      if (event.deltaY > 0 && _this.inner.scrollHeight <= _this.inner.scrollTop + _this.inner.offsetHeight) {
        event.preventDefault();
        return false;
      }
      if (event.deltaY < 0 && _this.inner.scrollTop <= 0) {
        event.preventDefault();
        return false;
      }
    };
    _this.handleMouseMove = function (event) {
      var right = event.currentTarget.getBoundingClientRect().right - event.pageX;
      _this.setHover(right <= 12);
    };
    _this.handleMouseLeave = function () {
      _this.setHover(false);
    };
    return _this;
  }
  ScrollContainer.prototype.componentDidMount = function () {
    this.reflow();
  };
  ScrollContainer.prototype.componentDidUpdate = function (prevProps) {
    if (this.inner) {
      if (prevProps.preventWindowScroll && !this.props.preventWindowScroll) {
        this.inner.removeEventListener('wheel', this.handleInnerScrollWheel);
      }
      if (!prevProps.preventWindowScroll && this.props.preventWindowScroll) {
        this.inner.addEventListener('wheel', this.handleInnerScrollWheel, { passive: false });
      }
    }
    this.reflow();
  };
  ScrollContainer.prototype.render = function () {
    var _a;
    var state = this.state;
    var props = this.props;
    var scroll = null;
    if (state.scrollActive) {
      var scrollClass = Emotion_1.cx((_a = {},
      _a[ScrollContainer_module_less_1["default"].scroll] = true,
      _a[ScrollContainer_module_less_1["default"].scrollInvert] = !!props.invert,
      _a[ScrollContainer_module_less_1["default"].scrollHover] = state.hover || state.scrolling,
      _a));
      var scrollStyle = {
        top: state.scrollPos,
        height: state.scrollSize };

      scroll = React.createElement("div", { ref: this.refScroll, className: scrollClass, style: scrollStyle, onMouseDown: this.handleScrollMouseDown });
    }
    var innerStyle = {
      marginRight: this.getMarginRight(),
      maxHeight: props.maxHeight,
      paddingRight: PADDING_RIGHT,
      scrollBehavior: props.scrollBehaviour };

    return React.createElement("div", { className: ScrollContainer_module_less_1["default"].root, onMouseMove: this.handleMouseMove, onMouseLeave: this.handleMouseLeave },
    scroll,
    React.createElement("div", { className: ScrollContainer_module_less_1["default"].inner, style: innerStyle, ref: this.refInner, onScroll: this.handleNativeScroll }, props.children));
  };
  /**
      * @public
      */
  ScrollContainer.prototype.scrollTo = function (element) {
    if (!element || !this.inner) {
      return;
    }
    var maxScroll = element.offsetTop;
    if (this.inner.scrollTop > maxScroll) {
      this.inner.scrollTop = maxScroll;
      return;
    }
    var minScroll = element.offsetTop + element.scrollHeight - this.inner.offsetHeight;
    if (this.inner.scrollTop < minScroll) {
      this.inner.scrollTop = minScroll;
    }
  };
  /**
      * @public
      */
  ScrollContainer.prototype.scrollToTop = function () {
    if (!this.inner) {
      return;
    }
    this.inner.scrollTop = 0;
  };
  /**
      * @public
      */
  ScrollContainer.prototype.scrollToBottom = function () {
    if (!this.inner) {
      return;
    }
    this.inner.scrollTop = this.inner.scrollHeight - this.inner.offsetHeight;
  };
  ScrollContainer.prototype.setHover = function (hover) {
    if (this.state.hover !== hover) {
      this.setState({ hover: hover });
    }
  };
  ScrollContainer.prototype.getImmediateScrollState = function () {
    if (!this.inner || this.inner.scrollTop === 0) {
      return 'top';
    } else
    if (this.inner.scrollTop === this.inner.scrollHeight - this.inner.offsetHeight) {
      return 'bottom';
    } else
    {
      return 'scroll';
    }
  };
  ScrollContainer.prototype.getMarginRight = function () {
    return -1 * (PADDING_RIGHT + (SCROLL_HIDDEN ? 0 : getScrollWidth_1["default"]()));
  };
  ScrollContainer.__KONTUR_REACT_UI__ = 'ScrollContainer';
  ScrollContainer.propTypes = {
    invert: PropTypes.bool,
    maxHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
    scrollBehaviour: PropTypes.oneOf(['auto', 'smooth']),
    preventWindowScroll: PropTypes.bool,
    onScrollStateChange: PropTypes.func };

  ScrollContainer.defaultProps = {
    scrollBehaviour: 'auto' };

  return ScrollContainer;
}(React.Component);
exports["default"] = ScrollContainer;