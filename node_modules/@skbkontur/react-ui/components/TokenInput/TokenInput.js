"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var warning_1 = tslib_1.__importDefault(require("warning"));
var ReactDOM = tslib_1.__importStar(require("react-dom"));
var identifiers_1 = require("../../lib/events/keyboard/identifiers");
var TextWidthHelper_1 = tslib_1.__importDefault(require("./TextWidthHelper"));
var TokenInputMenu_1 = tslib_1.__importDefault(require("./TokenInputMenu"));
var TokenInputReducer_1 = require("./TokenInputReducer");
var LayoutEvents_1 = tslib_1.__importDefault(require("../../lib/LayoutEvents"));
var TokenInput_module_less_1 = tslib_1.__importDefault(require("./TokenInput.module.css"));
var Token_1 = tslib_1.__importDefault(require("../Token"));
var lodash_isequal_1 = tslib_1.__importDefault(require("lodash.isequal"));
var utils_1 = require("../../lib/utils");
var Emotion_1 = require("../../lib/theming/Emotion");
var TokenInput_styles_1 = tslib_1.__importDefault(require("./TokenInput.styles"));
var ThemeConsumer_1 = require("../ThemeConsumer");
var TokenInputType;
(function (TokenInputType) {
  TokenInputType[TokenInputType["WithReference"] = 0] = "WithReference";
  TokenInputType[TokenInputType["WithoutReference"] = 1] = "WithoutReference";
  TokenInputType[TokenInputType["Combined"] = 2] = "Combined";
})(TokenInputType = exports.TokenInputType || (exports.TokenInputType = {}));
var defaultToKey = function defaultToKey(item) {return item.toString();};
var identity = function identity(item) {return item;};
var defaultRenderToken = function defaultRenderToken(item, _a) {
  var isActive = _a.isActive,onClick = _a.onClick,onRemove = _a.onRemove,disabled = _a.disabled;
  return React.createElement(Token_1["default"], { key: item.toString(), isActive: isActive, onClick: onClick, onRemove: onRemove, disabled: disabled }, item);
};
var TokenInput = /** @class */function (_super) {
  tslib_1.__extends(TokenInput, _super);
  function TokenInput() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      inputValue: '',
      inputValueWidth: 20,
      activeTokens: [] };

    _this.input = null;
    _this.tokensInputMenu = null;
    _this.textHelper = null;
    _this.wrapper = null;
    _this.hasValueInItems = function (items, value) {
      if (typeof value === 'string') {
        return items.includes(value);
      }
      // todo: как то не очень
      return items.some(function (item) {return lodash_isequal_1["default"](item, value);});
    };
    _this.inputRef = function (node) {return _this.input = node;};
    _this.tokensInputMenuRef = function (node) {return _this.tokensInputMenu = node;};
    _this.textHelperRef = function (node) {return _this.textHelper = node;};
    _this.wrapperRef = function (node) {return _this.wrapper = node;};
    _this.dispatch = function (action, cb) {
      _this.setState(function (prevState) {return TokenInputReducer_1.tokenInputReducer(prevState, action);}, cb);
    };
    _this.handleInputFocus = function (event) {
      _this.dispatch({ type: 'SET_FOCUS_IN' });
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };
    _this.handleInputBlur = function (event) {
      if (_this.isBlurToMenu(event) || _this.state.preventBlur) {
        event.preventDefault();
        // первый focus нужен для предотвращения/уменьшения моргания в других браузерах
        _this.input.focus();
        // в firefox не работает без второго focus
        process.nextTick(function () {return _this.input.focus();});
        _this.dispatch({ type: 'SET_PREVENT_BLUR', payload: false });
      } else
      {
        _this.dispatch({ type: 'BLUR' });
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
    };
    _this.isBlurToMenu = function (event) {
      if (_this.menuRef) {
        var menu = ReactDOM.findDOMNode(_this.menuRef);
        var relatedTarget = event.relatedTarget || document.activeElement;
        if (menu && menu.contains(relatedTarget)) {
          return true;
        }
      }
      return false;
    };
    _this.handleWrapperMouseDown = function (event) {
      _this.dispatch({ type: 'SET_PREVENT_BLUR', payload: true });
      var target = event.target;
      var isClickOnToken = target && _this.wrapper.contains(target) && target !== _this.wrapper && target !== _this.input;
      if (!isClickOnToken) {
        _this.dispatch({ type: 'REMOVE_ALL_ACTIVE_TOKENS' });
      }
    };
    _this.handleWrapperMouseUp = function () {
      _this.dispatch({ type: 'SET_PREVENT_BLUR', payload: false });
    };
    _this.handleCopy = function (event) {
      if (!_this.state.inFocus || _this.state.activeTokens.length === 0 || _this.isCursorVisible) {
        return;
      }
      event.preventDefault();
      // упорядочивание токенов по индексу
      var tokens = _this.state.activeTokens.
      map(function (token) {return _this.props.selectedItems.indexOf(token);}).
      sort().
      map(function (index) {return _this.props.selectedItems[index];}).
      map(function (item) {return _this.props.valueToString(item);});
      event.clipboardData.setData('text/plain', tokens.join(_this.delimiters[0]));
    };
    _this.handleInputPaste = function (event) {
      if (_this.type === TokenInputType.WithReference || !event.clipboardData) {
        return;
      }
      var paste = event.clipboardData.getData('text');
      var delimiters = _this.delimiters;
      if (delimiters.some(function (delimiter) {return paste.includes(delimiter);})) {
        event.preventDefault();
        event.stopPropagation();
        for (var _i = 0, delimiters_1 = delimiters; _i < delimiters_1.length; _i++) {
          var delimiter = delimiters_1[_i];
          paste = paste.split(delimiter).join(delimiters[0]);
        }
        var tokens = paste.split(delimiters[0]);
        var items = tokens.
        map(function (token) {return _this.props.valueToItem(token);}).
        filter(function (item) {return !_this.hasValueInItems(_this.props.selectedItems, item);});
        var newItems = _this.props.selectedItems.concat(items);
        _this.props.onChange(newItems);
      }
    };
    _this.tryGetItems = function (query) {
      if (query === void 0) {query = '';}
      return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var autocompleteItems, autocompleteItemsUnique;
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
          switch (_a.label) {
            case 0:
              if (!(this.props.getItems && (this.state.inputValue !== '' || !this.props.hideMenuIfEmptyInputValue))) return [3 /*break*/, 2];
              this.dispatch({ type: 'SET_LOADING', payload: true });
              return [4 /*yield*/, this.props.getItems(query)];
            case 1:
              autocompleteItems = _a.sent();
              this.dispatch({ type: 'SET_LOADING', payload: false });
              autocompleteItemsUnique = autocompleteItems.filter(function (item) {return !_this.hasValueInItems(_this.props.selectedItems, item);});
              if (query === '' || this.state.inputValue !== '') {
                this.dispatch({ type: 'SET_AUTOCOMPLETE_ITEMS', payload: autocompleteItemsUnique }, function () {
                  LayoutEvents_1["default"].emit();
                  _this.highlightMenuItem();
                });
              }
              _a.label = 2;
            case 2:return [2 /*return*/];}

        });
      });
    };
    _this.handleKeyDown = function (event) {
      if (_this.isCursorVisible) {
        _this.handleInputKeyDown(event);
      } else
      {
        _this.handleWrapperKeyDown(event);
      }
    };
    _this.handleInputKeyDown = function (e) {
      e.stopPropagation();
      if (_this.type !== TokenInputType.WithReference && (identifiers_1.isKeyEnter(e) || _this.delimiters.includes(e.key))) {
        e.preventDefault();
        var newValue = _this.state.inputValue;
        if (newValue !== '') {
          _this.handleAddItem(newValue);
        }
      }
      switch (true) {
        case identifiers_1.isKeyEnter(e):
          if (_this.menuRef) {
            _this.menuRef.enter(e);
          }
          break;
        case identifiers_1.isKeyArrowVertical(e):
          e.preventDefault();
          if (_this.menuRef) {
            if (identifiers_1.isKeyArrowUp(e)) {
              _this.menuRef.up();
            } else
            {
              _this.menuRef.down();
            }
          }
          break;
        case identifiers_1.isKeyEscape(e):
          _this.input.blur();
          break;
        case identifiers_1.isKeyBackspace(e):
          _this.moveFocusToLastToken();
          break;
        case identifiers_1.isKeyArrowLeft(e):
          if (_this.input.selectionStart === 0) {
            _this.moveFocusToLastToken();
          }
          break;}

    };
    _this.focusInput = function () {
      process.nextTick(function () {return _this.input.focus();});
    };
    _this.handleWrapperKeyDown = function (e) {
      switch (true) {
        case identifiers_1.isKeyBackspace(e):
        case identifiers_1.isKeyDelete(e):
          var itemsNew = _this.props.selectedItems.filter(function (item) {return !_this.hasValueInItems(_this.state.activeTokens, item);});
          _this.props.onChange(itemsNew);
          _this.dispatch({ type: 'REMOVE_ALL_ACTIVE_TOKENS' }, function () {
            LayoutEvents_1["default"].emit();
            _this.input.focus();
          });
          break;
        case identifiers_1.isKeyArrowHorizontal(e):
          _this.handleWrapperArrows(e);
          break;
        case identifiers_1.isKeyEscape(e):
          _this.wrapper.blur();
          break;
        case identifiers_1.isShortcutSelectAll(e):
          e.preventDefault();
          _this.dispatch({
            type: 'SET_ACTIVE_TOKENS',
            payload: _this.props.selectedItems });

          break;}

    };
    _this.handleWrapperArrows = function (e) {
      e.preventDefault();
      var activeTokens = _this.state.activeTokens;
      var activeItemIndex = _this.props.selectedItems.indexOf(activeTokens[0]);
      var newItemIndex = activeItemIndex + (identifiers_1.isKeyArrowLeft(e) ? -1 : +1);
      var isLeftEdge = activeItemIndex === 0 && identifiers_1.isKeyArrowLeft(e);
      var isRightEdge = activeItemIndex === _this.props.selectedItems.length - 1 && identifiers_1.isKeyArrowRight(e);
      if (!e.shiftKey && activeTokens.length === 1) {
        _this.handleWrapperArrowsWithoutShift(isLeftEdge, isRightEdge, newItemIndex);
      } else
      {
        _this.handleWrapperArrowsWithShift(isLeftEdge, isRightEdge, newItemIndex);
      }
    };
    _this.handleWrapperArrowsWithoutShift = function (isLeftEdge, isRightEdge, newItemIndex) {
      if (isRightEdge) {
        _this.dispatch({ type: 'REMOVE_ALL_ACTIVE_TOKENS' }, function () {return _this.input.focus();});
      } else
      if (!isLeftEdge) {
        _this.dispatch({
          type: 'SET_ACTIVE_TOKENS',
          payload: [_this.props.selectedItems[newItemIndex]] });

      }
    };
    _this.handleWrapperArrowsWithShift = function (isLeftEdge, isRightEdge, newItemIndex) {
      if (!isLeftEdge && !isRightEdge) {
        var itemNew_1 = _this.props.selectedItems[newItemIndex];
        var itemsNew = [itemNew_1].concat(_this.state.activeTokens.filter(function (item) {return !lodash_isequal_1["default"](item, itemNew_1);}));
        _this.dispatch({ type: 'SET_ACTIVE_TOKENS', payload: itemsNew });
      }
    };
    _this.handleChange = function (item) {
      if (_this.hasValueInItems(_this.props.selectedItems, item)) {
        return;
      }
      var newItems = _this.props.selectedItems.concat([item]);
      _this.props.onChange(newItems);
      _this.dispatch({ type: 'CLEAR_INPUT' });
      _this.tryGetItems();
    };
    _this.handleAddItem = function (item) {
      var value = _this.props.valueToItem(item);
      if (_this.hasValueInItems(_this.props.selectedItems, value)) {
        return;
      }
      var newItems = _this.props.selectedItems.concat([value]);
      _this.props.onChange(newItems);
      _this.dispatch({ type: 'CLEAR_INPUT' });
      _this.tryGetItems();
    };
    _this.handleRemoveToken = function (item) {
      _this.props.onChange(_this.props.selectedItems.filter(function (_) {return !lodash_isequal_1["default"](_, item);}));
      var filteredActiveTokens = _this.state.activeTokens.filter(function (_) {return !lodash_isequal_1["default"](_, item);});
      _this.dispatch({ type: 'SET_ACTIVE_TOKENS', payload: filteredActiveTokens });
      if (filteredActiveTokens.length === 0) {
        _this.focusInput();
      }
      _this.tryGetItems();
    };
    _this.handleTokenClick = function (event, itemNew) {
      var items = _this.state.activeTokens;
      if (event.ctrlKey) {
        var newItems = _this.hasValueInItems(_this.state.activeTokens, itemNew) ?
        items.filter(function (item) {return !lodash_isequal_1["default"](item, itemNew);}) :
        items.concat([itemNew]);
        _this.dispatch({ type: 'SET_ACTIVE_TOKENS', payload: newItems });
      } else
      {
        _this.dispatch({ type: 'SET_ACTIVE_TOKENS', payload: [itemNew] });
      }
      _this.focusInput();
    };
    _this.handleChangeInputValue = function (event) {
      var query = event.target.value.trimLeft();
      if (query.endsWith(' ')) {
        query = query.trimRight() + ' ';
      }
      if (_this.state.inputValue !== '' && query === '') {
        _this.dispatch({ type: 'SET_AUTOCOMPLETE_ITEMS', payload: undefined });
      }
      _this.dispatch({ type: 'UPDATE_QUERY', payload: query }, function () {return _this.tryGetItems(query);});
    };
    _this.highlightMenuItem = function () {
      if (_this.menuRef &&
      _this.state.autocompleteItems &&
      _this.state.autocompleteItems.length > 0 &&
      _this.type !== TokenInputType.Combined) {
        _this.menuRef.highlightItem(0);
      }
    };
    _this.renderTokenFields = function () {
      return _this.props.selectedItems.map(_this.renderTokenSelector);
    };
    _this.renderTokenSelector = function (item) {
      switch (true) {
        case _this.props.renderToken !== undefined:
          return _this.renderToken(item);
        case _this.props.renderTokenComponent !== undefined:
          return _this.renderTokenComponent(item);
        default:
          return _this.renderToken(item);}

    };
    /**
        * @deprecated
        */
    _this.renderTokenComponent = function (item) {
      if (process.env.NODE_ENV !== 'production') {
        warning_1["default"](_this.props.renderTokenComponent !== undefined, "Prop `renderTokenComponent` has been deprecated, use `renderToken` instead");
      }
      var _a = _this.props,renderValue = _a.renderValue,toKey = _a.toKey,disabled = _a.disabled;
      var isActive = _this.state.activeTokens.indexOf(item) !== -1;
      var handleIconClick = function handleIconClick(event) {
        event.stopPropagation();
        _this.handleRemoveToken(item);
      };
      var handleTokenClick = function handleTokenClick(event) {
        event.stopPropagation();
        _this.handleTokenClick(event, item);
      };
      var token = function token(_a) {
        var _b = _a === void 0 ? {} : _a,colors = _b.colors,error = _b.error,warning = _b.warning;
        return React.createElement(Token_1["default"], tslib_1.__assign({}, {
          key: toKey(item),
          isActive: isActive,
          disabled: disabled,
          colors: colors,
          error: error,
          warning: warning,
          onClick: handleTokenClick,
          onRemove: handleIconClick,
          children: renderValue(item) }));

      };
      if (_this.props.renderTokenComponent) {
        return _this.props.renderTokenComponent(token, item);
      }
      // DEAD CODE
      return token();
    };
    _this.renderToken = function (item) {
      var _a = _this.props,_b = _a.renderToken,renderToken = _b === void 0 ? defaultRenderToken : _b,disabled = _a.disabled;
      var isActive = _this.state.activeTokens.indexOf(item) !== -1;
      // TODO useCallback
      var handleIconClick = function handleIconClick(event) {
        event.stopPropagation();
        _this.handleRemoveToken(item);
      };
      // TODO useCallback
      var handleTokenClick = function handleTokenClick(event) {
        event.stopPropagation();
        _this.handleTokenClick(event, item);
      };
      return renderToken(item, {
        isActive: isActive,
        onClick: handleTokenClick,
        onRemove: handleIconClick,
        disabled: disabled });

    };
    return _this;
  }
  TokenInput.prototype.componentDidMount = function () {
    this.updateInputTextWidth();
    document.addEventListener('copy', this.handleCopy);
    if (this.props.autoFocus) {
      this.focusInput();
    }
  };
  TokenInput.prototype.componentDidUpdate = function (prevProps, prevState) {
    if (prevState.inputValue !== this.state.inputValue) {
      this.updateInputTextWidth();
    }
    if (prevState.activeTokens.length === 0 && this.state.activeTokens.length > 0) {
      this.dispatch({
        type: 'SET_AUTOCOMPLETE_ITEMS',
        payload: undefined });

    }
    if (prevProps.selectedItems.length !== this.props.selectedItems.length) {
      LayoutEvents_1["default"].emit();
    }
    if (!this.isCursorVisibleForState(prevState) && this.isCursorVisible) {
      this.tryGetItems(this.state.inputValue);
    }
  };
  TokenInput.prototype.componentWillUnmount = function () {
    document.removeEventListener('copy', this.handleCopy);
  };
  TokenInput.prototype.render = function () {
    var _this = this;
    return React.createElement(ThemeConsumer_1.ThemeConsumer, null, function (theme) {
      _this.theme = theme;
      return _this.renderMain();
    });
  };
  TokenInput.prototype.renderMain = function () {
    var _a, _b;
    if (this.type !== TokenInputType.WithoutReference && !this.props.getItems) {
      throw Error('Missed getItems for type ' + this.type);
    }
    var _c = this.props,selectedItems = _c.selectedItems,width = _c.width,maxMenuHeight = _c.maxMenuHeight,error = _c.error,warning = _c.warning,disabled = _c.disabled,placeholder = _c.placeholder,renderItem = _c.renderItem,renderNotFound = _c.renderNotFound,hideMenuIfEmptyInputValue = _c.hideMenuIfEmptyInputValue,onMouseEnter = _c.onMouseEnter,onMouseLeave = _c.onMouseLeave;
    var _d = this.state,activeTokens = _d.activeTokens,inFocus = _d.inFocus,inputValueWidth = _d.inputValueWidth,inputValue = _d.inputValue,autocompleteItems = _d.autocompleteItems,loading = _d.loading;
    var showMenu = this.type !== TokenInputType.WithoutReference &&
    this.isCursorVisible &&
    activeTokens.length === 0 && (
    inputValue !== '' || !hideMenuIfEmptyInputValue);
    var inputInlineStyles = {
      // вычисляем ширину чтобы input автоматически перенёсся на следующую строку при необходимости
      width: Math.max(50, inputValueWidth + 7),
      // input растягивается на всю ширину чтобы placeholder не обрезался
      flex: selectedItems && selectedItems.length === 0 ? 1 : undefined,
      // в ie не работает, но альтернативный способ --- дать tabindex для label --- предположительно ещё сложнее
      caretColor: this.isCursorVisible ? undefined : 'transparent' };

    var theme = this.theme;
    var labelClassName = Emotion_1.cx(TokenInput_module_less_1["default"].label, TokenInput_styles_1["default"].label(theme), (_a = {},
    _a[TokenInput_styles_1["default"].labelFocused(theme)] = !!inFocus,
    _a[TokenInput_styles_1["default"].error(theme)] = !!error,
    _a[TokenInput_styles_1["default"].warning(theme)] = !!warning,
    _a[TokenInput_styles_1["default"].labelDisabled(theme)] = !!disabled,
    _a));
    var inputClassName = Emotion_1.cx(TokenInput_module_less_1["default"].input, TokenInput_styles_1["default"].input(theme), (_b = {},
    _b[TokenInput_module_less_1["default"].inputDisabled] = !!disabled,
    _b[TokenInput_styles_1["default"].inputDisabled(theme)] = !!disabled,
    _b));
    return React.createElement("div", { className: TokenInput_module_less_1["default"].root, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave },
    React.createElement(TextWidthHelper_1["default"], { ref: this.textHelperRef, text: inputValue }),
    React.createElement("label", { ref: this.wrapperRef, style: { width: width }, className: labelClassName, onMouseDown: this.handleWrapperMouseDown, onMouseUp: this.handleWrapperMouseUp },
    this.renderTokenFields(),
    React.createElement("input", { type: "text", ref: this.inputRef, value: inputValue, style: inputInlineStyles, autoComplete: "off", spellCheck: false, disabled: disabled, className: inputClassName, placeholder: selectedItems.length > 0 ? undefined : placeholder, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur, onChange: this.handleChangeInputValue, onKeyDown: this.handleKeyDown, onPaste: this.handleInputPaste }),
    showMenu && React.createElement(TokenInputMenu_1["default"], { ref: this.tokensInputMenuRef, items: autocompleteItems, loading: loading, opened: showMenu, maxMenuHeight: maxMenuHeight, anchorElement: this.input, inputValue: inputValue, renderNotFound: renderNotFound, renderItem: renderItem, onAddItem: this.handleAddItem, onChange: this.handleChange, showAddItemHint: this.showAddItemHint })));
  };
  Object.defineProperty(TokenInput.prototype, "showAddItemHint", {
    get: function get() {
      var items = this.state.autocompleteItems;
      var value = this.props.valueToItem(this.state.inputValue);
      if (items && this.hasValueInItems(items, value)) {
        return false;
      }
      var selectedItems = this.props.selectedItems;
      if (selectedItems && this.hasValueInItems(selectedItems, value)) {
        return false;
      }
      if (this.type === TokenInputType.Combined && this.state.inputValue !== '') {
        return true;
      }
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(TokenInput.prototype, "type", {
    get: function get() {
      return this.props.type ? this.props.type : TokenInputType.WithReference;
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(TokenInput.prototype, "delimiters", {
    get: function get() {
      return this.props.delimiters ? this.props.delimiters : [','];
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(TokenInput.prototype, "menuRef", {
    get: function get() {
      return this.tokensInputMenu && this.tokensInputMenu.getMenuRef();
    },
    enumerable: true,
    configurable: true });

  Object.defineProperty(TokenInput.prototype, "isCursorVisible", {
    get: function get() {
      return this.isCursorVisibleForState(this.state);
    },
    enumerable: true,
    configurable: true });

  TokenInput.prototype.isCursorVisibleForState = function (state) {
    return state.inFocus && (state.inputValue !== '' || state.activeTokens.length === 0);
  };
  TokenInput.prototype.updateInputTextWidth = function () {
    if (this.textHelper) {
      var inputValueWidth = this.textHelper.getTextWidth();
      this.dispatch({ type: 'SET_INPUT_VALUE_WIDTH', payload: inputValueWidth }, LayoutEvents_1["default"].emit);
    }
  };
  TokenInput.prototype.moveFocusToLastToken = function () {
    var items = this.props.selectedItems;
    if (this.state.inputValue === '' && items && items.length > 0) {
      this.dispatch({ type: 'SET_ACTIVE_TOKENS', payload: items.slice(-1) });
    }
  };
  TokenInput.__KONTUR_REACT_UI__ = 'TokenInput';
  TokenInput.defaultProps = {
    selectedItems: [],
    renderItem: identity,
    renderValue: identity,
    valueToString: identity,
    valueToItem: function valueToItem(item) {return item;},
    toKey: defaultToKey,
    onChange: function onChange() {return void 0;},
    width: 250,
    onBlur: utils_1.emptyHandler,
    onFocus: utils_1.emptyHandler,
    onMouseEnter: utils_1.emptyHandler,
    onMouseLeave: utils_1.emptyHandler };

  return TokenInput;
}(React.PureComponent);
exports["default"] = TokenInput;