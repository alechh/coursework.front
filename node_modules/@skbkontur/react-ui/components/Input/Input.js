"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = tslib_1.__importStar(require("react"));
var identifiers_1 = require("../../lib/events/keyboard/identifiers");
var polyfillPlaceholder_1 = tslib_1.__importDefault(require("../polyfillPlaceholder"));
require("../ensureOldIEClassName");
var invariant_1 = tslib_1.__importDefault(require("invariant"));
var MaskedInput_1 = tslib_1.__importDefault(require("../internal/MaskedInput/MaskedInput"));
var Emotion_1 = require("../../lib/theming/Emotion");
var Input_module_less_1 = tslib_1.__importDefault(require("./Input.module.css"));
var Input_styles_1 = tslib_1.__importDefault(require("./Input.styles"));
var ThemeConsumer_1 = require("../ThemeConsumer");
var raf_1 = tslib_1.__importDefault(require("raf"));
/**
                                                      * Интерфес пропсов наследуется от `React.InputHTMLAttributes<HTMLInputElement>`.
                                                      *  Все пропсы кроме перечисленных, `className` и `style` передаются в `<input>`
                                                      */
var Input = /** @class */function (_super) {
  tslib_1.__extends(Input, _super);
  function Input() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      polyfillPlaceholder: false,
      blinking: false,
      focused: false };

    _this.selectAllId = null;
    _this.blinkTimeout = 0;
    _this.input = null;
    /**
                         * @public
                         */
    _this.selectAll = function () {
      if (_this.input) {
        _this.setSelectionRange(0, _this.input.value.length);
      }
    };
    _this.delaySelectAll = function () {return _this.selectAllId = raf_1["default"](_this.selectAll);};
    _this.cancelDelayedSelectAll = function () {
      if (_this.selectAllId) {
        raf_1["default"].cancel(_this.selectAllId);
        _this.selectAllId = null;
      }
    };
    _this.cancelBlink = function (callback) {
      if (_this.blinkTimeout) {
        clearTimeout(_this.blinkTimeout);
        _this.blinkTimeout = 0;
        if (_this.state.blinking) {
          _this.setState({ blinking: false }, callback);
          return;
        }
      }
      if (callback) {
        callback();
      }
    };
    _this.refInput = function (element) {
      if (element instanceof MaskedInput_1["default"]) {
        _this.input = element.input;
      } else
      {
        _this.input = element;
      }
    };
    _this.handleChange = function (event) {
      if (polyfillPlaceholder_1["default"]) {
        var fieldIsEmpty = event.target.value === '';
        if (_this.state.polyfillPlaceholder !== fieldIsEmpty) {
          _this.setState({ polyfillPlaceholder: fieldIsEmpty });
        }
      }
      if (_this.props.onChange) {
        _this.props.onChange(event, event.target.value);
      }
    };
    _this.handleFocus = function (event) {
      _this.setState({
        focused: true });

      if (_this.props.selectAllOnFocus) {
        // https://github.com/facebook/react/issues/7769
        _this.input ? _this.selectAll() : _this.delaySelectAll();
      }
      if (_this.props.onFocus) {
        _this.props.onFocus(event);
      }
    };
    _this.handleKeyDown = function (e) {
      if (_this.props.onKeyDown) {
        _this.props.onKeyDown(e);
      }
      var isDeleteKey = identifiers_1.someKeys(identifiers_1.isKeyBackspace, identifiers_1.isKeyDelete)(e);
      if (!e.currentTarget.value && isDeleteKey && !e.repeat) {
        _this.handleUnexpectedInput();
      }
    };
    _this.handleKeyPress = function (event) {
      if (_this.props.onKeyPress) {
        _this.props.onKeyPress(event);
      }
      if (_this.props.maxLength === event.currentTarget.value.length) {
        _this.handleUnexpectedInput();
      }
    };
    _this.handleUnexpectedInput = function () {
      if (_this.props.onUnexpectedInput) {
        _this.props.onUnexpectedInput();
      } else
      {
        _this.blink();
      }
    };
    _this.handleBlur = function (event) {
      _this.setState({ focused: false });
      if (_this.props.onBlur) {
        _this.props.onBlur(event);
      }
    };
    _this.renderPrefix = function () {
      var prefix = _this.props.prefix;
      if (!prefix) {
        return null;
      }
      return React.createElement("span", { className: Input_styles_1["default"].prefix(_this.theme) }, prefix);
    };
    _this.renderSuffix = function () {
      var suffix = _this.props.suffix;
      if (!suffix) {
        return null;
      }
      return React.createElement("span", { className: Input_styles_1["default"].suffix(_this.theme) }, suffix);
    };
    return _this;
  }
  Input.prototype.componentDidMount = function () {
    if (polyfillPlaceholder_1["default"]) {
      this.setState({ polyfillPlaceholder: true });
    }
  };
  Input.prototype.componentWillUnmount = function () {
    if (this.blinkTimeout) {
      clearTimeout(this.blinkTimeout);
    }
    this.cancelDelayedSelectAll();
  };
  Input.prototype.componentWillReceiveProps = function (nextProps) {
    if (polyfillPlaceholder_1["default"] && !nextProps.value) {
      this.setState({ polyfillPlaceholder: true });
    }
  };
  /**
      * @public
      */
  Input.prototype.focus = function () {
    invariant_1["default"](this.input, 'Cannot call "focus" because Input is not mounted');
    this.input.focus();
  };
  /**
      * @public
      */
  Input.prototype.blur = function () {
    invariant_1["default"](this.input, 'Cannot call "blur" because Input is not mounted');
    this.input.blur();
  };
  /**
      * @public
      */
  Input.prototype.blink = function () {
    var _this = this;
    if (this.blinkTimeout) {
      this.cancelBlink(function () {
        // trigger reflow to restart animation
        // @see https://css-tricks.com/restart-css-animation/#article-header-id-0
        // tslint:disable-next-line:no-unused-expression
        void (_this.input && _this.input.offsetWidth);
        _this.blink();
      });
      return;
    }
    this.setState({ blinking: true }, function () {
      _this.blinkTimeout = window.setTimeout(_this.cancelBlink, 150);
    });
  };
  /**
      * @public
      */
  Input.prototype.setSelectionRange = function (start, end) {
    if (!this.input) {
      throw new Error('Cannot call "setSelectionRange" on unmounted Input');
    }
    if (document.activeElement !== this.input) {
      this.focus();
    }
    this.input.setSelectionRange(start, end);
  };
  Object.defineProperty(Input.prototype, "isMaskVisible", {
    get: function get() {
      var _a = this.props,mask = _a.mask,alwaysShowMask = _a.alwaysShowMask;
      var focused = this.state.focused;
      return Boolean(mask && (focused || alwaysShowMask));
    },
    enumerable: true,
    configurable: true });

  Input.prototype.render = function () {
    var _this = this;
    return React.createElement(ThemeConsumer_1.ThemeConsumer, null, function (theme) {
      _this.theme = theme;
      return _this.renderMain();
    });
  };
  Input.prototype.renderMain = function () {
    var _a;
    var _b = this.props,onMouseEnter = _b.onMouseEnter,onMouseLeave = _b.onMouseLeave,onMouseOver = _b.onMouseOver,onKeyDown = _b.onKeyDown,onKeyPress = _b.onKeyPress,width = _b.width,error = _b.error,warning = _b.warning,leftIcon = _b.leftIcon,rightIcon = _b.rightIcon,borderless = _b.borderless,value = _b.value,align = _b.align,type = _b.type,mask = _b.mask,maskChar = _b.maskChar,alwaysShowMask = _b.alwaysShowMask,style = _b.style,className = _b.className,size = _b.size,placeholder = _b.placeholder,mainInGroup = _b.mainInGroup,selectAllOnFocus = _b.selectAllOnFocus,disabled = _b.disabled,onUnexpectedInput = _b.onUnexpectedInput,prefix = _b.prefix,suffix = _b.suffix,formatChars = _b.formatChars,rest = tslib_1.__rest(_b, ["onMouseEnter", "onMouseLeave", "onMouseOver", "onKeyDown", "onKeyPress", "width", "error", "warning", "leftIcon", "rightIcon", "borderless", "value", "align", "type", "mask", "maskChar", "alwaysShowMask", "style", "className", "size", "placeholder", "mainInGroup", "selectAllOnFocus", "disabled", "onUnexpectedInput", "prefix", "suffix", "formatChars"]);
    var _c = this.state,blinking = _c.blinking,focused = _c.focused;
    var labelProps = {
      className: Emotion_1.cx(Input_module_less_1["default"].root, Input_styles_1["default"].root(this.theme), this.getSizeClassName(), (_a = {},
      _a[Input_module_less_1["default"].focus] = focused,
      _a[Input_module_less_1["default"].disabled] = !!disabled,
      _a[Input_module_less_1["default"].error] = !!error,
      _a[Input_module_less_1["default"].warning] = !!warning,
      _a[Input_module_less_1["default"].borderless] = !!borderless,
      _a[Input_styles_1["default"].focus(this.theme)] = focused,
      _a[Input_styles_1["default"].blink(this.theme)] = !!blinking,
      _a[Input_styles_1["default"].warning(this.theme)] = !!warning,
      _a[Input_styles_1["default"].error(this.theme)] = !!error,
      _a[Input_styles_1["default"].disabled(this.theme)] = !!disabled,
      _a)),
      style: { width: width },
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      onMouseOver: onMouseOver };

    var inputProps = tslib_1.__assign({}, rest, { className: Emotion_1.cx(Input_module_less_1["default"].input, Input_styles_1["default"].input(this.theme)), value: value, onChange: this.handleChange, onFocus: this.handleFocus, onKeyDown: this.handleKeyDown, onKeyPress: this.handleKeyPress, onBlur: this.handleBlur, style: { textAlign: align }, ref: this.refInput, type: 'text', placeholder: !this.isMaskVisible && !polyfillPlaceholder_1["default"] ? placeholder : undefined, disabled: disabled });
    if (type === 'password') {
      inputProps.type = type;
    }
    var input = !!mask ? this.renderMaskedInput(inputProps, mask) : React.createElement('input', inputProps);
    return React.createElement("label", tslib_1.__assign({}, labelProps),
    React.createElement("span", { className: Input_module_less_1["default"].sideContainer },
    this.renderLeftIcon(),
    this.renderPrefix()),
    React.createElement("span", { className: Input_module_less_1["default"].wrapper },
    input,
    this.renderPlaceholder()),
    React.createElement("span", { className: Emotion_1.cx(Input_module_less_1["default"].sideContainer, Input_module_less_1["default"].rightContainer) },
    this.renderSuffix(),
    this.renderRightIcon()));
  };
  Input.prototype.renderMaskedInput = function (inputProps, mask) {
    return React.createElement(MaskedInput_1["default"], tslib_1.__assign({}, inputProps, { mask: mask, maskChar: this.props.maskChar === undefined ? '_' : this.props.maskChar, alwaysShowMask: this.props.alwaysShowMask, onUnexpectedInput: this.handleUnexpectedInput, formatChars: this.props.formatChars }));
  };
  Input.prototype.renderLeftIcon = function () {
    return this.renderIcon(this.props.leftIcon, Input_module_less_1["default"].leftIcon);
  };
  Input.prototype.renderRightIcon = function () {
    return this.renderIcon(this.props.rightIcon, Input_module_less_1["default"].rightIcon);
  };
  Input.prototype.renderIcon = function (icon, className) {
    if (!icon) {
      return null;
    }
    if (icon instanceof Function) {
      return React.createElement("span", { className: className }, icon());
    }
    return React.createElement("span", { className: Emotion_1.cx(className, Input_module_less_1["default"].useDefaultColor, Input_styles_1["default"].useDefaultColor(this.theme)) }, icon);
  };
  Input.prototype.renderPlaceholder = function () {
    var placeholder = null;
    if (this.state.polyfillPlaceholder && this.props.placeholder && !this.isMaskVisible && !this.props.value) {
      placeholder = React.createElement("div", { className: Emotion_1.cx(Input_module_less_1["default"].placeholder, Input_styles_1["default"].placeholder(this.theme)), style: { textAlign: this.props.align || 'inherit' } }, this.props.placeholder);
    }
    return placeholder;
  };
  Input.prototype.getSizeClassName = function () {
    switch (this.props.size) {
      case 'large':
        return Input_styles_1["default"].sizeLarge(this.theme);
      case 'medium':
        return Input_styles_1["default"].sizeMedium(this.theme);
      case 'small':
      default:
        return Input_styles_1["default"].sizeSmall(this.theme);}

  };
  Input.__KONTUR_REACT_UI__ = 'Input';
  Input.defaultProps = {
    size: 'small' };

  return Input;
}(React.Component);
exports["default"] = Input;