{"ast":null,"code":"/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule BaseEventEmitter\r\n * @typechecks\r\n */\n'use strict';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError('Cannot call a class as a function');\n  }\n}\n\nvar EmitterSubscription = require('./EmitterSubscription');\n\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\n\nvar emptyFunction = require('fbjs/lib/emptyFunction');\n\nvar invariant = require('fbjs/lib/invariant');\n/**\r\n * @class BaseEventEmitter\r\n * @description\r\n * An EventEmitter is responsible for managing a set of listeners and publishing\r\n * events to them when it is told that such events happened. In addition to the\r\n * data for the given event it also sends a event control object which allows\r\n * the listeners/handlers to prevent the default behavior of the given event.\r\n *\r\n * The emitter is designed to be generic enough to support all the different\r\n * contexts in which one might want to emit events. It is a simple multicast\r\n * mechanism on top of which extra functionality can be composed. For example, a\r\n * more advanced emitter may use an EventHolder and EventFactory.\r\n */\n\n\nvar BaseEventEmitter = function () {\n  /**\r\n   * @constructor\r\n   */\n  function BaseEventEmitter() {\n    _classCallCheck(this, BaseEventEmitter);\n\n    this._subscriber = new EventSubscriptionVendor();\n    this._currentSubscription = null;\n  }\n  /**\r\n   * Adds a listener to be invoked when events of the specified type are\r\n   * emitted. An optional calling context may be provided. The data arguments\r\n   * emitted will be passed to the listener function.\r\n   *\r\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\r\n   *       can be invoked with varargs.\r\n   *\r\n   * @param {string} eventType - Name of the event to listen to\r\n   * @param {function} listener - Function to invoke when the specified event is\r\n   *   emitted\r\n   * @param {*} context - Optional context object to use when invoking the\r\n   *   listener\r\n   */\n\n\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\n  };\n  /**\r\n   * Similar to addListener, except that the listener is removed after it is\r\n   * invoked once.\r\n   *\r\n   * @param {string} eventType - Name of the event to listen to\r\n   * @param {function} listener - Function to invoke only once when the\r\n   *   specified event is emitted\r\n   * @param {*} context - Optional context object to use when invoking the\r\n   *   listener\r\n   */\n\n\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\n    var emitter = this;\n    return this.addListener(eventType, function () {\n      emitter.removeCurrentListener();\n      listener.apply(context, arguments);\n    });\n  };\n  /**\r\n   * Removes all of the registered listeners, including those registered as\r\n   * listener maps.\r\n   *\r\n   * @param {?string} eventType - Optional name of the event whose registered\r\n   *   listeners to remove\r\n   */\n\n\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\n    this._subscriber.removeAllSubscriptions(eventType);\n  };\n  /**\r\n   * Provides an API that can be called during an eventing cycle to remove the\r\n   * last listener that was invoked. This allows a developer to provide an event\r\n   * object that can remove the listener (or listener map) during the\r\n   * invocation.\r\n   *\r\n   * If it is called when not inside of an emitting cycle it will throw.\r\n   *\r\n   * @throws {Error} When called not during an eventing cycle\r\n   *\r\n   * @example\r\n   *   var subscription = emitter.addListenerMap({\r\n   *     someEvent: function(data, event) {\r\n   *       console.log(data);\r\n   *       emitter.removeCurrentListener();\r\n   *     }\r\n   *   });\r\n   *\r\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\r\n   *   emitter.emit('someEvent', 'def'); // does not log anything\r\n   */\n\n\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\n\n    this._subscriber.removeSubscription(this._currentSubscription);\n  };\n  /**\r\n   * Returns an array of listeners that are currently registered for the given\r\n   * event.\r\n   *\r\n   * @param {string} eventType - Name of the event to query\r\n   * @return {array}\r\n   */\n\n\n  BaseEventEmitter.prototype.listeners = function listeners(eventType)\n  /* TODO: Array<EventSubscription> */\n  {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\n      return subscription.listener;\n    }) : [];\n  };\n  /**\r\n   * Emits an event of the given type with the given data. All handlers of that\r\n   * particular type will be notified.\r\n   *\r\n   * @param {string} eventType - Name of the event to emit\r\n   * @param {*} Arbitrary arguments to be passed to each registered listener\r\n   *\r\n   * @example\r\n   *   emitter.addListener('someEvent', function(message) {\r\n   *     console.log(message);\r\n   *   });\r\n   *\r\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\r\n   */\n\n\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\n\n    if (subscriptions) {\n      var keys = Object.keys(subscriptions);\n\n      for (var ii = 0; ii < keys.length; ii++) {\n        var key = keys[ii];\n        var subscription = subscriptions[key]; // The subscription may have been removed during this event loop.\n\n        if (subscription) {\n          this._currentSubscription = subscription;\n\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\n        }\n      }\n\n      this._currentSubscription = null;\n    }\n  };\n  /**\r\n   * Provides a hook to override how the emitter emits an event to a specific\r\n   * subscription. This allows you to set up logging and error boundaries\r\n   * specific to your environment.\r\n   *\r\n   * @param {EmitterSubscription} subscription\r\n   * @param {string} eventType\r\n   * @param {*} Arbitrary arguments to be passed to each registered listener\r\n   */\n\n\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\n    var args = Array.prototype.slice.call(arguments, 2);\n    subscription.listener.apply(subscription.context, args);\n  };\n\n  return BaseEventEmitter;\n}();\n\nmodule.exports = BaseEventEmitter;","map":{"version":3,"sources":["C:/Users/Sasha/Documents/coursework.front/node_modules/fbemitter/lib/BaseEventEmitter.js"],"names":["_classCallCheck","instance","Constructor","TypeError","EmitterSubscription","require","EventSubscriptionVendor","emptyFunction","invariant","BaseEventEmitter","_subscriber","_currentSubscription","prototype","addListener","eventType","listener","context","addSubscription","once","emitter","removeCurrentListener","apply","arguments","removeAllListeners","removeAllSubscriptions","process","env","NODE_ENV","undefined","removeSubscription","listeners","subscriptions","getSubscriptionsForType","filter","thatReturnsTrue","map","subscription","emit","keys","Object","ii","length","key","__emitToSubscription","concat","Array","slice","call","args","module","exports"],"mappings":"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","sourcesContent":["/**\r\n * Copyright (c) 2014-present, Facebook, Inc.\r\n * All rights reserved.\r\n *\r\n * This source code is licensed under the BSD-style license found in the\r\n * LICENSE file in the root directory of this source tree. An additional grant\r\n * of patent rights can be found in the PATENTS file in the same directory.\r\n *\r\n * @providesModule BaseEventEmitter\r\n * @typechecks\r\n */\r\n\r\n'use strict';\r\n\r\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\r\n\r\nvar EmitterSubscription = require('./EmitterSubscription');\r\nvar EventSubscriptionVendor = require('./EventSubscriptionVendor');\r\n\r\nvar emptyFunction = require('fbjs/lib/emptyFunction');\r\nvar invariant = require('fbjs/lib/invariant');\r\n\r\n/**\r\n * @class BaseEventEmitter\r\n * @description\r\n * An EventEmitter is responsible for managing a set of listeners and publishing\r\n * events to them when it is told that such events happened. In addition to the\r\n * data for the given event it also sends a event control object which allows\r\n * the listeners/handlers to prevent the default behavior of the given event.\r\n *\r\n * The emitter is designed to be generic enough to support all the different\r\n * contexts in which one might want to emit events. It is a simple multicast\r\n * mechanism on top of which extra functionality can be composed. For example, a\r\n * more advanced emitter may use an EventHolder and EventFactory.\r\n */\r\n\r\nvar BaseEventEmitter = (function () {\r\n  /**\r\n   * @constructor\r\n   */\r\n\r\n  function BaseEventEmitter() {\r\n    _classCallCheck(this, BaseEventEmitter);\r\n\r\n    this._subscriber = new EventSubscriptionVendor();\r\n    this._currentSubscription = null;\r\n  }\r\n\r\n  /**\r\n   * Adds a listener to be invoked when events of the specified type are\r\n   * emitted. An optional calling context may be provided. The data arguments\r\n   * emitted will be passed to the listener function.\r\n   *\r\n   * TODO: Annotate the listener arg's type. This is tricky because listeners\r\n   *       can be invoked with varargs.\r\n   *\r\n   * @param {string} eventType - Name of the event to listen to\r\n   * @param {function} listener - Function to invoke when the specified event is\r\n   *   emitted\r\n   * @param {*} context - Optional context object to use when invoking the\r\n   *   listener\r\n   */\r\n\r\n  BaseEventEmitter.prototype.addListener = function addListener(eventType, listener, context) {\r\n    return this._subscriber.addSubscription(eventType, new EmitterSubscription(this._subscriber, listener, context));\r\n  };\r\n\r\n  /**\r\n   * Similar to addListener, except that the listener is removed after it is\r\n   * invoked once.\r\n   *\r\n   * @param {string} eventType - Name of the event to listen to\r\n   * @param {function} listener - Function to invoke only once when the\r\n   *   specified event is emitted\r\n   * @param {*} context - Optional context object to use when invoking the\r\n   *   listener\r\n   */\r\n\r\n  BaseEventEmitter.prototype.once = function once(eventType, listener, context) {\r\n    var emitter = this;\r\n    return this.addListener(eventType, function () {\r\n      emitter.removeCurrentListener();\r\n      listener.apply(context, arguments);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Removes all of the registered listeners, including those registered as\r\n   * listener maps.\r\n   *\r\n   * @param {?string} eventType - Optional name of the event whose registered\r\n   *   listeners to remove\r\n   */\r\n\r\n  BaseEventEmitter.prototype.removeAllListeners = function removeAllListeners(eventType) {\r\n    this._subscriber.removeAllSubscriptions(eventType);\r\n  };\r\n\r\n  /**\r\n   * Provides an API that can be called during an eventing cycle to remove the\r\n   * last listener that was invoked. This allows a developer to provide an event\r\n   * object that can remove the listener (or listener map) during the\r\n   * invocation.\r\n   *\r\n   * If it is called when not inside of an emitting cycle it will throw.\r\n   *\r\n   * @throws {Error} When called not during an eventing cycle\r\n   *\r\n   * @example\r\n   *   var subscription = emitter.addListenerMap({\r\n   *     someEvent: function(data, event) {\r\n   *       console.log(data);\r\n   *       emitter.removeCurrentListener();\r\n   *     }\r\n   *   });\r\n   *\r\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\r\n   *   emitter.emit('someEvent', 'def'); // does not log anything\r\n   */\r\n\r\n  BaseEventEmitter.prototype.removeCurrentListener = function removeCurrentListener() {\r\n    !!!this._currentSubscription ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Not in an emitting cycle; there is no current subscription') : invariant(false) : undefined;\r\n    this._subscriber.removeSubscription(this._currentSubscription);\r\n  };\r\n\r\n  /**\r\n   * Returns an array of listeners that are currently registered for the given\r\n   * event.\r\n   *\r\n   * @param {string} eventType - Name of the event to query\r\n   * @return {array}\r\n   */\r\n\r\n  BaseEventEmitter.prototype.listeners = function listeners(eventType) /* TODO: Array<EventSubscription> */{\r\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\r\n    return subscriptions ? subscriptions.filter(emptyFunction.thatReturnsTrue).map(function (subscription) {\r\n      return subscription.listener;\r\n    }) : [];\r\n  };\r\n\r\n  /**\r\n   * Emits an event of the given type with the given data. All handlers of that\r\n   * particular type will be notified.\r\n   *\r\n   * @param {string} eventType - Name of the event to emit\r\n   * @param {*} Arbitrary arguments to be passed to each registered listener\r\n   *\r\n   * @example\r\n   *   emitter.addListener('someEvent', function(message) {\r\n   *     console.log(message);\r\n   *   });\r\n   *\r\n   *   emitter.emit('someEvent', 'abc'); // logs 'abc'\r\n   */\r\n\r\n  BaseEventEmitter.prototype.emit = function emit(eventType) {\r\n    var subscriptions = this._subscriber.getSubscriptionsForType(eventType);\r\n    if (subscriptions) {\r\n      var keys = Object.keys(subscriptions);\r\n      for (var ii = 0; ii < keys.length; ii++) {\r\n        var key = keys[ii];\r\n        var subscription = subscriptions[key];\r\n        // The subscription may have been removed during this event loop.\r\n        if (subscription) {\r\n          this._currentSubscription = subscription;\r\n          this.__emitToSubscription.apply(this, [subscription].concat(Array.prototype.slice.call(arguments)));\r\n        }\r\n      }\r\n      this._currentSubscription = null;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Provides a hook to override how the emitter emits an event to a specific\r\n   * subscription. This allows you to set up logging and error boundaries\r\n   * specific to your environment.\r\n   *\r\n   * @param {EmitterSubscription} subscription\r\n   * @param {string} eventType\r\n   * @param {*} Arbitrary arguments to be passed to each registered listener\r\n   */\r\n\r\n  BaseEventEmitter.prototype.__emitToSubscription = function __emitToSubscription(subscription, eventType) {\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    subscription.listener.apply(subscription.context, args);\r\n  };\r\n\r\n  return BaseEventEmitter;\r\n})();\r\n\r\nmodule.exports = BaseEventEmitter;"]},"metadata":{},"sourceType":"script"}